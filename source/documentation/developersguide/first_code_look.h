/*! \page first_code_look First Look At Code
Becoming familiar with a new code base is always a challenge, and Picto is no exception.  To help with this process, we have spent a great deal of time documenting Picto to the functional level.  At this point, every funciton in Picto should be documented, as should all variables in the protected or public scope.  Even with all of this information, you will need some guidance to get started.  The purpose of this file is to provide some guidelines for getting started with the code base on your way to developing a deeper familiarity with it.  

Picto consists of four main applications, the Workstation, Server, Director and Proxy plus a sort of sub-application, the EmbeddedFrontPanel application that controls the front panel and buttons on the Pictobox.  All of these projects are defined within their own Visual Studio project files (.vcxproj) which are included in the Picto.sln.  The visual studio projects themselves are built by using 
\code 
	ConfigureX86.cmd
	tools\qt.config\mypaths.cmd
	tools\win.common\GenerateBuildFiles.cmd
\endcode
in the Visual Studio Command Prompt (See \ref build_environment_preparation for more details).  The GenerateBuildFiles.cmd itself uses the various .pro files scattered around the Picto/src directory tree to figure out how to build the .vcxproj files.  In this vain, be aware that whenever you want to add a file to one of the Picto projects, you need to do it by adding the header and cpp files to that project's .pro file and then rerunning the scripts outlined above.

As far as the individual applications go, different approaches may be taken in building a familiarity with each one.  We go through tips for starting out with each of the application code bases below.

\section first_look_Workstation Workstation
Execution of the Workstation starts at the main method in workstation\main.cpp, but the MainWindow.cpp is what really manages the main Workstation window.  Start by looking at MainWindow::createViewers() and MainWindow::changeMode(), these functions will give you as sense of how navigation works within the MainWindow.  After that familiarize yourself with some of the other MainWindow functions, then move onto the classes that extend Viewer, namely RemoteViewer, ReplayViewer, StateEditViewer, and TestViewer, and work down from there.  In particular, before working your way down to far, you will need to have a good sense of the Design Tree structure.  Look at Picto::Serializable, Picto::Asset and Picto::DataStore to get a sense of how serialization works.  Take a look at Picto::Property and Picto::PropertyContainer to understand where data is stored within Picto::DataStore objects at its lowest level.  Next, start at Picto::Experiment and work your way down through its child Picto::Task object to Picto::StateMachine.  Picto::StateMachine will give you a good sense of how control flow traverses through the Picto design.  It will lead you to look at Picto::State, Picto::SwitchElement and other Picto::StateMachineElement objects.  Once you are somewhat familiar with control flow, you can start working your way through the class inheritance tree that provides the functionality to things like Picto::State, Picto::VisualElement, etc.

Once you are familiar with the Design stucture, you can get back to the individual Viewers.  
	- The StateEditViewer is really just a container for the Picto::Designer, so you'll want to look at that.  When you are moving through all of the various widgets that the Designer uses, keep in mind that the Picto::EditorState is very important.  It is the glue that holds the Designer together, allowing different widgets to communicate through the use of Qt Signals and Slots.
	- The TestViewer contains some complexity associated with selecting, setting up and running Analyses that can be a little distracting.  When starting out, focus on the TestPlaybackController.  This is where the code that actually runs the Experiment Tasks lives.
	- Before looking through the RemoteViewer, look at the Picto::SlaveExperimentDriver, Picto::StateUpdater system and the RemoteStateUpdater implementation of StateUpdater.  These define the system that allows a master Experiment to control a slave, and the RemoteViewer uses them to run the SlaveExperiment.
	- The ReplayViewer should be much clearer if you've gone through the Picto::SlaveExperimentDriver, Picto::StateUpdater system from the RemoteViewer guidelines.  The ReplayViewer uses the same setup, except that the Picto::StateUpdater in this case is a PlaybackStateUpdater controlled by a PlaybackController that runs in its own thread.  Again, there is some complexity associated with setting up, selecting and activating Analyses in the ReplayViewer code that can be distracting.  If you can start with an understanding of how the PlaybackController manages playback, it should make the ReplayViewer functionality a little bit clearer.

\section first_look_Server Server
Parts of the Server dealing with the actual sending an receiving of data over the network socket can get somewhat complicated.  It is best to start with the high level function of the Server and save its low level infrastructure for later.  Start out with the assumption that the Server recieves commands from the Director, Proxy and Workstation, somehow processes them and sends them into the appropriate ProtocolCommandHandler.  The classes that extend ProtocolCommandHandler can be found in server\\protocol.  Focus on the main interfaces for the workstation: StartSessionCommandHandler and TaskCommandHandler, and the main interfaces for the Director and Proxy: PutDataCommandHandler and ComponentUpdateCommandHandler.  These handlers will lead you into exploring the ConnectionManager class and the particularly important SessionInfo class, which is really the heart of the Server application.

Once you have gone through these pieces, you can look back at the Server infrastructure: Server, ServerThread, Picto::ProtocolCommand, etc.  The main method for the Server application, in server\\main.cpp happens to be particularly complicated since the application can be run from both the command line and as a system service.  It is not all that important that you understand the details of what is happening in server\\main.cpp unless you need to edit it.  Don't spend too much time on it at this stage.

\section first_look_Director Director
The Director class inherits ComponentInterface, and the application is essentially started when Director\\main.cpp calls Picto::ComponentInterface::activate().  It would be a good idea to start by looking through Picto::ComponentInterface.  Next, look at Director and try to get a good idea of how it is implementing the ComponentInterface.  At this point, although it is somewhat counter intuitive, it would be a good idea to look at Picto::CommandChannel::processResponses().  This turns out to be a vitally important function for both the Director and Proxy, more details are available in that function's documentation.  After looking at the processResponses() function, check out the classes in director\\protocol that extend the various ProtocolResponseHandler classes along with Picto::StatusManager and DirectorStatusManager.  In particular, DirectorStartResponseHandler does the work of actually running the Experiment Task.

\section first_look_Proxy Proxy
Like the Director, the Proxy class inherits ComponentInterface, and the application is essentially started when the ProxyMainWindow's Picto::ComponentInterface::activate() function is called.  In the Proxy's case, the function is called due to a one shot timer in the ProxyMainWindow constructor.  Assuming that you have gone through the Director section, you have already looked at  Picto::ComponentInterface and Picto::CommandChannel::processResponses().  Next you should look at the ProxyNewSessionResponseHandler.  Its ProxyNewSessionResponseHander::processResponse() function is actually responsible for capturing and sending Proxy data to the server.  Next, look at NeuralDataAcqInterface.  This class is implemented in each of the Proxy plugins, for Plexon, TDT and the Virtual Device.  In each case, the class that implements NeuralDataAcqInterface takes care of interfacing with the actual Neural Data Acquisition device.  Now you should have a pretty broad sense of how the Proxy works, and you can look back at ProxyMainWindow for some of the GUI details.

\section first_look_Embedded Embedded Front Panel
The EmbeddedFrontPanel application is fairly simple.  The main method of embedded\\frontpanel\\main.cpp creates a Menu object and a Phidgets object.  Phidgets handles the interface to the Pictobox front panel and knob hardware, Menu handles the logic controlling what is displayed on the hardware.  Start by looking at Menu.  In particular, look at Menu::loadMenus() where the various DisplayMode options are setup, and Menu::userInputSlot() where input from the Phidgets dial cause the current DisplayMode to switch.  Next look at the DisplayMode class and go over some of its child classes.  Check out DirectorInterface to see how the EmbeddedFrontPanel actually interfaces with the Director.  Don't spend too much time worrying about the details of the Phidgets class.  It looks complicated, but is really just a translator from the world of Phidgets to the world of the EmbeddedFrontPanel.  Unless Phidgets adds some new feature or something, you probably won't need to do much to it.

 */
