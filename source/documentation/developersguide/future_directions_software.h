/*! \page future_directions_software Future Directions in Software
The following is a list of features that we would like to add to the Picto application suite.  Some of these features are purely for the purpose of expanding Picto capability.  Others are really refactorizations for the purpose of removing limitations in the the current system.  Obviously this is not an exhaustive list, and the more features that we add, the more feature ideas we will undoubtedly come up with.  In cases where we have given some thought to how a feature should be implemented, we have included it in this list.  In other cases, implementation is entirely up to you the developer.

<b>Picto Experiments should be run as part of the Qt event loop</b><br>
Picto Tasks are not currently run as part of the Qt Event loop.  Currently, Picto::Experiment::runTask() starts a task and doesn't return until the Task is complete.  In order for Tasks to run as part of the Qt event loop, we would need to set a timer to trigger a top level runFrameLogic() function every frame from the event loop.  This function would locate the current Task control state, then cause all scripts to run and all transitions to be traversed until control reached the code that renders the next frame.  We would then wait for first phosphor presentation in that frame, run any code that needs to happen at the time of the first phosphor, and return to the event loop.  Any OS events, network events, etc could then happen as a natural part of the Qt event loop in the time between first phosphor presentations and processing for the next render.  This would allow a whole lot of things in Picto to run a whole lot more smoothly.  In particular, right now in Picto any time we send a message over the network to the Server, rather than using the standard method of connecting to network events, we need to find a place in local logic to poll the network socket and wait for a response.  Inevitably, this ends up wasting a lot of time and seriously complicating the code.  The reason that Picto wasn't built to run as part of the Qt event loop in the first place is due to computers having being historically slower that they are now and the fear that allowing the Director application to handle OS events might cause skipped frames.  At this point it is our belief, considering the simplicity of our Experiments and the speed of new processors, that allowing the Director application to handle OS events will not have any effect on frame rate.  For more details on this issue, see Picto::CommandChannel::processResponses().  Also, note that the implementation of this feature is a very significant task that involves touching a lot of pieces of Picto code.  It should definitely not be taken on as one of a new developer's first tasks.

<b>Add LFP and Spike data to a ReplayViewer audio channel</b><br>
Currently, while LFP and Spike data are available from Analysis code, they are not presented in any way in the ReplayViewer GUI.  There are a number of possibilities for presenting this data.  In the case of the RemoteViewer, the data is presented in a separate tab on a plot; however, experience shows that one of the most convenient ways to present the data is over an audio channel so that researchers can hear changes to neural data while simultaneously watching what is going on in the behavioral task.  In the RemoteViewer, for various reasons, there is at least a half second delay between the current behavioral time and LFP data coming in from the neural system which makes a live audio signal less feasible.  In the ReplayViewer, however, we should be able to playback neural data in an audio channel while the behavioral task is being played back.  The idea would be to allow the operator to select a channel/unit and playback all spikes on that channel/unit as simple ticks.  LFP data for that channel would be directly pumped into the audio stream as a background hum behind the spike ticks.  In terms of implementation, the spike/lfp playback system is already in place but there is some plumbing that will need to be done in bringing the Picto::SessionState::lfpChanged() and Picto::SessionState::spikeEvent() signals up to the StateUpdater interface.  Once there, we should be able to connect to those signals and send their data out to an audio channel.  More recent versions of Qt have exposed a lot of new functionality for dealing with audio and multimedia in general.  In searching for a method of outputing raw audio data, that would be a good place to start.

<b>Add AnalysisVisualElements to the Analysis system</b><br>
Currently, there is one means of output for Analyses which is the AnalysisFileOutput.  The AnalysisFileOutput comes with a AnalysisFileOutputWidget that displays output file data in a side bar of the ReplayViewer and TestViewer during playback.  When we record Session playback into a video file though, we only record what happes in the main window of the ReplayViewer and it would be nice to be able to add new information to that display such that it overlays what was happening during the Session.  The simplest way to do this would be to add AnalysisVisualElements that would be added to Analyses and displayed with exactly the same rules as their Experimental VisualElement counter parts when their Analysis was activated.  There could be any number of AnalysisVisualElement classes for displaying text, xyPlots, rasterPlots, progressBars, etc.  This way, if a researcher wanted to show how a specific piece of data changes during the course of a trial, they could simply add an appropriate AnalysisVisualElement and update it accordingly while the trial progressed.  Imagine, for example, if we implemented a raster AnalysisVisualElement.  During the course of each trail, in each frame script we could use an AnalysisFunction to send the latest spikes to the raster plot.  The raster could be placed at the bottom of the display such that our video file would show not only what the test subject was doing during the trial, but also how a correlated neuron's spike density changed during that trial.

<b>Add Audio to video files</b><br>
Currently, video files recorded from the ReplayViewer do not record sound.  It turns out that adding audio to the video file is harder than you might expect.  In fact, as of this writing, even with all of its new multimedia functionality Qt does not provide any convenient way of programmatically generating a video file (it's support is limited to capturing and saving images from a webcam - see my stack overflow question on the topic: http://stackoverflow.com/questions/14566470/create-video-programmatically-with-qt-5-0).  We used qtffmpegwrapper for this purpose.  qtffmpegwrapper is a qt interface to the ffmpeg system and does the job in a not-to-complicated way, but does not support audio.  The qtffmpegwrapper along with all necessary ffmpeg binaries is stored in Picto\\3rdparty\\qtffmpegwrapper.  It will undoubtedly need to be updated at some point when Windows changes their API or something and can be found online at https://code.google.com/p/qtffmpegwrapper/.  To add audio support to saved Picto videos though, you'll need to either change the qtffmpegwrapper code to add an audio interface (unless someone else has already done it by the time you read this), use Qt directly if it has added video writing support by now, or find some better method.

<b>Integrate Picto analysis with Matlab</b><br>
This feature is more of a long term goal and we haven't done much research on it as of yet.  The idea is to make use of the Matlab API to send Analysis output data directly to Matlab.  Depending on how flexible the Matlab API is, we could possibly put Matlab plots and other windows directly into the AnalysisOutputWidgetContainer, use them a pop-ups or simply pipe data into a running Matlab application.  The method for doing this is up to you, but the idea would be to implement the interface inside a MatlabAnalysisOutput object (ie. MatlabPlotAnalysisOutput) that could be added to a Picto Analysis design just like any other AnalysisOutput object.

<b>Put all Picto systems onto one Server</b><br>
The orignal plan for Picto was to have one central server that handles all running Picto Sessions simultaneously.  In fact, the current Picto Server is capable of handling a small number of simultaneous Sessions on different Directors so long as the Sessions are simple without large quantities of data like LFP.  The problem with handling multiple Sessions at once is that there is so much overhead in writing data to SQL.  We found that due to this overhead, a single Picto Session with neural data can take up a very significant percentage of Server processing time, and for this reason the decision was made to add system numbers so that multiple Servers could run on the same network and run a separate Server for every Director/Proxy system.  The fact is though, that the data saved on the Picto Server is almost entirely serial, and there really is no need to perform any SQL read queries on the Session data during the course of a Session.  For this reason, it would make sense to reimplement the SessionInfo code (and StoredSessionData) such that it saves data in a simple file as a simple byte array.  It is certainly good for finalized Session files to be saved in SQL for the purpose of easy upgrading and debugging, so a separate tool could be created to convert the simple serial file to an SQL file.  This tool could be run when the Server wasn't busy handling Sessions overnight to convert the previous days saved data to SQL Session files.  In the spacial case where a Workstation wants to analyze Session data right away, we could add the tool to the Workstation so that it could perform the conversion on its own.  We have not run tests of saving serial file data, but it should remove file access as the Server bottleneck since generally file access is considered much quicker than interfacing over a network.

<b>Add line numbers to Picto Scripts</b><br>
We will need to extend the ScriptTextEdit class to do this.

<b>Implement standardized region/manifold/channel data storage</b><br>
When recording with neural data, it is important to save information about the neural recording setup used with a particular session.  Currently, researchers can do this by adding the relevant data to the RunNotes in the RemoteViewer; however since this needs to be done by everyone for every Session, it would be good to set up a standard way to do this.  It would also be very useful if the method allowed the data to be searchable in the future so that, for example, we could select out all sessions that dealt with a particular brain region.  There are many ways to do this.  One that comes to mind would be to add some type of additonal configuration to the Picto Server.  The Server could be configured with a list of categories for which data could be saved and a list of possible values for each category.  The Workstation could then query the saveable categories and category values when it joins/starts a Session.  In the TaskRunViewer, it could provide a section with a little '+' button to add a new category and category value, each of which could be filled in using drop down menus.  The values entered there could then be sent to the Server along with the RunNotes and saved in a searchable SQL table in the Session file.  By doing things in this way, we would make it easy to search over multiple Sessions for particular Region/Manifold/Channel values.  We would also leave things general so that the categories could be set up differently for other research applications.

<b>Implement getToken(index) function on TokenFactoryGraphic</b><br>
We have recieved some user feedback indicating that it would be very useful to be able to treat individual tokens in a TokenFactoryGraphic as their own separate objects with their own functions and script properties.  This would not add any new functionality to Picto but it would make design more convenient for systems that require configurable numbers of tokens.  This should be doable by creating a Token class that inherits QObject and interfaces with the TokenFactoryGraphic whenever getToken(index) is called and adding it to the current QScriptEngine (hopefully the current QScriptEngine is accessible somehow).  Remember that whenever we add a new function or script property to anything we need to be very sure of it.  As soon as someone uses a that script function/property, we need Picto to be backward compatible with it forever!

<b>Allow Neural Data Acquisition systems and the Proxy to stop and start during the course of a Session</b><br>
Currently, if the Plexon or TDT systems stop recording during the course of a Session, even if they restart the Proxy is unable to gather any further data until a new Session is started with that Proxy.  Similarly, if a Proxy is closed accidentally, even if it is opened again it cannot reconnect to its Session and continue gathering data.  It would be good if we could support these functions.

<b>Add settable waveform sample period to Proxy</b><br>
Currently, every waveform that is recorded on the TDT or Plexon systems is sent to the Server and saved to the Session file.  This wastes space since it really is not necessary to save every single waveform.  It would be nice to add an option to the Proxy window to select the waveform sample period.

<b>Add "link to syntax error" in StateEditViewer</b><br>
The StateEditViewer includes a syntax checker system that reports script and structural errors in a tab of the bottom centeral widget.  It would be nice if you could click on these errors and cause the StateEditViewer context to automatically move to the element with the error.  In the case of script syntax errors, it would be nice if the cursor could automatically enter the problematic script at the error line.

<b>Allow a Director to determine if it supports a given Experiment</b><br>
Some Experiment designs include elements that may not be supported by a Director.  For example, a Director running on a Pictobox that is connected to a Neural Data Aquisition system is configured without the "-onesided" tag since it uses its parallel port to send alignment codes to the neural system.  This means that that Director's parallel port can't be used as an output for a BinaryDataOutput object.  If an Experiment loaded onto that Director included a BinaryDataOutput object, it would be useful if the Director could send a NOTSUPPORTED command to let the Workstation know that the Director cannot run that Experiment and either the Director needs to be reconfigured or the Design adjusted.

<b>Speed up Undo/Redo and Delete operations</b><br>
For code simplicity's sake, the Undo/Redo and Delete operations all involve reloading a serialized Design from scratch.  In the case of a Delete, we do this to make sure that everything is set up in a clean way after the delete is completed.  In the case of Undo and Redo, we do this in order to make use of the QTextDocument's built in Undo / Redo functionality.  All we have to do is change an underlying QTextDocument containing the Design's serialized XML whenever an important operation happens.  To Undo or Redo, we just call Undo or Redo on that QTextDocument then reload the Design from XML.  The problem with this approach is that it is very slow.  There are two ways to solve this.  The first would be to speed up the deserialization process.  We might accomplish this by streamligning the AssetFactory system, wherein multiple different AssetFactory objects are created for every object in the StateMachine tree.  Also, part of the complexity in the serialization system is due to the fact that Picto orignally included a TextViewer that showed the actual XML code underlying the Experiment and allowed the user to change it.  We wanted to make sure that every operation in the StateEditViewer could be undone in a way that would affect only the exact area of code where the change occured but leave everything else intact.  In particular, we were concerned that the tabbing and xml comments shouldn't get changed or moved due to actions in the StateEditViewer.  Now that the TextViewer is no longer used these concerns are less important and if need be the serialization code could be made more efficient at the expense of allowing StateEditViewer operations to change more significant portions of the XML design file.  Still, it is likely that this won't be sufficient to really get the kind of speed that we want.  The other option would be to implement the Undo/Redo/Delete in a completely different way, and this would be a big job.  For Delete, it would mean very carefully going through the StateMachine tree code and making sure that a Delete won't break anything (currently actually deleting an element only sets a flag saying "don't serialize this element" out, this would mean actually deleting the element when delete is called).  For Undo and Redo, we would need to carefully define a command dispatch system that defines "do" and "undo" effects for every possible type of user action.  Then representations of the user actions would be added to a stack after being performed and we could move backwords through that stack performing "undo" effects when we Undo and forward performing "do" effects when we Redo.

<b>Create a StateMachineTreeView</b><br>
Currently, we can only look at one level of the StateMachine tree at a time.  It would be useful to add an additional widget in the style of the Windows directory tree that would let us look at multiple levels of the tree at the same time.

<b>Unauthorized Workstation's need a way to see if the Session is running</b><br>
When unauthorized Workstations join a Session, their play/pause/stop buttons are greyed out since they are not allowed to control the Session.  This means that they can't see the colors of those buttons, and that means that they can't differentiate between things like a Session that is stopped and one that is paused with no visible VisualElements.

<b>Rebuild Neural Channel/Unit lists in the RemoteViewer whenever a Run is started</b><br>
The RemoteViewer's NeuralViewer keeps track of which channels/units have data on them and adds those channels/units to its lists the first time that data is received.  These lists are not cleared until the Workstation detaches from the Session though, so a channel that was active in one run but not used in another can stick around in the RemoteViewer UI even though it is completely empty.  This should be fixed so that the channel/unit lists are cleared and rebuilt each time a new Run starts.

<b>Add verification that no two in-scope OutputSignal elements are controlling the same output port at the same time</b><br>
There is currently no syntax verification for checkihg whether two OutputSignal elements that are in scope at the same time are trying to control the same digital output port.  This is a design error and verification code to this effect should be added to the Design tree.

<b>Create a Picto Installer</b><br>
Picto is currently installed by copying over a standard group of binaries and running a "Visual Studio Redistributable" installation.  We should create a simple one shot installer for Picto at some point to streamline this process.

<b>Refactor the TestViewer as a master and slave Experiment running in parallel</b><br>
Once we have refactored the Experiment run system to be part of the Qt event loop, it should be fairly straightforward to implement the TestViewer as a master Experiment running in a Qt Window sending data to a slave Experiment that handles Analysis.  This will help us prepare for implementing real time Picto Analysis.

<b>Implement real-time Session Analysis</b><br>
The idea here is to allow the RemoteViewer to analyze an Actively running Session.  This will take a lot of thought.  Some challenges here are that the Analysis needs all data from the beginning of the Run.  It can't just look at the latest data as the current system does.  Another challenge is in dealing with AnalysisDataSource objects.  These may ask for future data which simply has not happened yet.  To handle situations like this, we may need to use two separate slave Experiments in the RemoteViewer.  One would show realtime behavioral data, and another would run in the background and perform Analysis.  The Analysis Slave Experiment would need some way to stop running whenever Analysis code requested "future" data that hadn't been generated yet and restart when the data bacame available.

*/
