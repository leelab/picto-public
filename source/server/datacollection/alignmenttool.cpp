#include <QSqlQuery>
#include <QSqlError>
#include <QSqlRecord>
#include <QStringList>
#include <QVariant>
#include <QDateTime>
#include <qDebug>

#include "alignmenttool.h"

AlignmentTool::AlignmentTool()
{
}

//This function takes two database files containing neural and behavioral 
//data, and merges them into a single file with a single timebase.  Since the
//behavioral data is generated by Picto and has a single timer that starts
//the experiment at 0.0000, we'll use the behavioral data's timebase as the
//base.
bool AlignmentTool::mergeDatabases(QString neuralDBFilename, QString behavioralDBFilename, QString mergedDBFilename)
{
	bool result;

	//open the database files
	if(!openDBs(neuralDBFilename,behavioralDBFilename,mergedDBFilename))
		return false;

	//set up the merged database
	initMergedDB();



	result = processAlignmentTable(&neuralDB,"neuralalignment");
	if(!result)
	{
		qDebug()<<"Unable to fix all errors";
		closeDBs();
		return false;
	}
	else
	{
		qDebug()<<"All errors fixed";
	}

	result = processAlignmentTable(&behavioralDB,"behavioralalignment");
	if(!result)
	{
		qDebug()<<"Unable to fix all errors";
		closeDBs();
		return false;
	}
	else
	{
		qDebug()<<"All errors fixed";
	}




	//Complete the alignment
	if(!align())
	{
		qDebug()<<"Alignment failed";
		closeDBs();
		return false;
	}
	qDebug()<<"Alignment complete";

	//TODO: this stuf:
	//merge the session tables
	//copy the remaining behavioral db tables

	closeDBs();
	return true;


}

//Align computes a linear least squares fit on the alignment codes.  The goal 
//is to compute the offset between the neural timestamps and the behavioral 
//timestamps.  The assumption is that both clocks are running at the same rate, 
//but are offset by some constant value.  We expect that the slope will be 1.

//The general results of the fit are stored in the msglog, while the fitting 
//results for each alignment code are stored in the trials table.

//Trials will be numbered from 1 to N, starting from the first trial
//for which there exists both neural and behavioral data.

//The alignment of the two data sources consists of the following process:
//  1. Try ALL possible alignments
//  2. Select the best alignment (based on correlation)
//  4. Store the results in the database

//Since we can control the data collection, we can assume that the neural 
//data starts before the behavioral data and ends afer it.  This will make 
//our alignment a lot easier.

//The function assumes that both alignment tables consist of consecutive incrementing
//codes (e.g. 5,5,6,6,7,7,...).  If this is not the case, the function's behavior is
//unpredictable.  However, since the tables were generated by the 
//processAlignmentTable function, they should be fine.

//Since align is a private function, and it is always called after the alignment tables are processed, 
//we're going to leave out some of the error checking (for example, it is aassumed that the 
//alignment tables exist).

bool AlignmentTool::align()
{
	QSqlQuery query(mergedDB);

	QDateTime currTime = QDateTime::currentDateTime();
	QString dateStr = currTime.date().toString("MM/dd/yyyy");
	QString timeStr = currTime.time().toString("hh:mm:ss");

	query.prepare("INSERT INTO msglog (type,message,dbname,date,time) "
		"VALUES ('info','Aligning timebases',:dbname,:date,:time)");
	query.bindValue(":dbname",mergedDB.connectionName());
	query.bindValue(":date",dateStr);
	query.bindValue(":time",timeStr);
	Q_ASSERT(query.exec());

	QList<double> nTimestamps;
	QList<int> nAligncodes;
	QList<double> bTimestamps;
	QList<int> bAligncodes;

	
	//read in the alignment tables
	Q_ASSERT(query.exec("SELECT timestamp, aligncode FROM neuralalignment ORDER BY timestamp"));
	while(query.next())
	{
		nTimestamps.push_back(query.value(0).toDouble());
		nAligncodes.push_back(query.value(1).toInt());
	}
	Q_ASSERT(query.exec("SELECT timestamp, aligncode FROM behavioralalignment ORDER BY timestamp"));
	while(query.next())
	{
		bTimestamps.push_back(query.value(0).toDouble());
		bAligncodes.push_back(query.value(1).toInt());
	}

	typedef struct {
		double a;		//intercept
		double b;		//slope
		double corr;	//correlation
		int offset;
	}alignmentInfo;

	QList<alignmentInfo> alignmentResults;
	int alignmentOffset=-1;
	
	//try all combinations (assuming that the neural data starts first and ends last)
	while(true)
	{
		alignmentInfo alignResult;

		alignmentOffset = nAligncodes.indexOf(bAligncodes[0],alignmentOffset+1);
		if(alignmentOffset + bAligncodes.size() > nAligncodes.size())
			break;
		if(alignmentOffset < 0)
			break;

		linearLeastSquares(nTimestamps, bTimestamps,alignmentOffset,0,alignResult.a, alignResult.b, alignResult.corr);
		alignResult.offset = alignmentOffset;

		alignmentResults.push_back(alignResult);
	}

	//confirm that at least one alignment was performed
	if(alignmentResults.empty())
	{
		query.prepare("INSERT INTO msglog (type,message,dbname,date,time) "
			"VALUES ('fatal','Unable to align timebases: codes not aligning', "
			":dbname,:date,:time)");
		query.bindValue(":dbname",mergedDB.connectionName());
		query.bindValue(":date",dateStr);
		query.bindValue(":time",timeStr);
		Q_ASSERT(query.exec());
		return false;
	}

	//select the best alignment
	int bestIdx = 0;

	for(int x=1; x<alignmentResults.size(); x++)
	{
		if(alignmentResults[x].corr > alignmentResults[bestIdx].corr)
			bestIdx = x;
	}

	double a = alignmentResults[bestIdx].a;
	double b = alignmentResults[bestIdx].b;
	double corr = alignmentResults[bestIdx].corr;
	double offset = alignmentResults[bestIdx].offset;

	//Put alignment results in message log
	QString message = QString("Alignment done.  A = %1, B = %2, corr = %3, offset = %4")
		.arg(a,0,'f',5).arg(b,0,'f',5).arg(corr,0,'f',5).arg(offset);
	query.prepare("INSERT INTO msglog (type,message,dbname,date,time) "
		"VALUES ('info',:message,:dbname,:date,:time)");
	query.bindValue(":message",message);
	query.bindValue(":dbname",mergedDB.connectionName());
	query.bindValue(":date",dateStr);
	query.bindValue(":time",timeStr);
	Q_ASSERT(query.exec());

	//do some sanity checks
	if(b>1.1 || b<0.9 || corr <0.95) //slope should be =1, and corr>0.95
	{
		query.prepare("INSERT INTO msglog (type,message,dbname,date,time) "
			"VALUES ('fatal','Alignment results poor.  Aborting.', "
			":dbname,:date,:time)");
		query.bindValue(":dbname",mergedDB.connectionName());
		query.bindValue(":date",dateStr);
		query.bindValue(":time",timeStr);
		return false;
	}

	//build the trials table
	int trialNum = 1;
	mergedDB.transaction();
	for(int x=0; x<bTimestamps.size(); x+=2)
	{
		double start,end,duration;
		double startJit, endJit, durationJit;

		//confirm that we really are aligned
		Q_ASSERT(bAligncodes[x] == bAligncodes[x+1]);
		Q_ASSERT(nAligncodes[x+offset] == nAligncodes[offset+x+1]);
		Q_ASSERT(bAligncodes[x] == nAligncodes[x+offset]);

		start = bTimestamps[x];
		end = bTimestamps[x+1];
		duration = end-start;
		startJit = bTimestamps[x] - (a + b*nTimestamps[offset+x]);
		endJit = bTimestamps[x+1] - (a + b*nTimestamps[offset+x+1]);
		durationJit = duration - (b*nTimestamps[offset+x+1] - b*nTimestamps[offset+x]);

		query.prepare("INSERT INTO trials (trialnumber,starttime,endtime,"
			"duration,startjitter,endjitter,durationjitter) "
			"VALUES (:trialnumber,:starttime,:endtime,"
			":duration,:startjitter,:endjitter,:durationjitter)");
		query.bindValue(":trialnumber",trialNum);
		query.bindValue(":starttime",start);
		query.bindValue(":endtime",end);
		query.bindValue(":duration",duration);
		query.bindValue(":startjitter",startJit);
		query.bindValue(":endjitter",endJit);
		query.bindValue(":durationjitter",durationJit);
		Q_ASSERT(query.exec());

		//check for excessive jitter
		if(startJit > 0.002 || startJit < -0.002 ||
			endJit > 0.002 || endJit < -0.002 ||
			durationJit > 0.002 || durationJit < -0.002)
		{
			QString message = QString("Excessive jitter on trial %1.").arg(trialNum);
			query.prepare("INSERT INTO msglog (type,message,dbname,tablename,date,time) "
				"VALUES ('warning',:message,:dbname,'trials',:date,:time)");
			query.bindValue(":message",message);
			query.bindValue(":dbname",mergedDB.connectionName());
			query.bindValue(":date",dateStr);
			query.bindValue(":time",timeStr);
			Q_ASSERT(query.exec());
		}

		trialNum++;
	}
	mergedDB.commit();

	//build the spikes table
	QSqlQuery neuralQuery(neuralDB);
	double newTime;


	neuralQuery.exec("SELECT timestamp,channel,unit,waveform FROM spikes ORDER BY timestamp");

	mergedDB.transaction();
	while(neuralQuery.next())
	{
		newTime = a + b*neuralQuery.value(0).toDouble();

		query.prepare("INSERT INTO spikes (timestamp,channel,unit,waveform) "
			"VALUES (:timestamp,:channel,:unit,:waveform)");
		query.bindValue(":timestamp",newTime);
		query.bindValue(":channel",neuralQuery.value(1).toString());
		query.bindValue(":unit",neuralQuery.value(2).toString());
		query.bindValue(":waveform",neuralQuery.value(3).toString());
		Q_ASSERT(query.exec());
	}
	mergedDB.commit();


	return true;

}



//Check that the alignment codes are incrementing in a sensible fashion.
//The alignment code should be generated at the start of a trial, and 
//again at the end of the trial.  The code increments after each trial.

//Note that the order of records in the database is completely irrelevant.
//All we care about is the timestamp order.

//Valid alignment code sequences:
//    58,58,59,59,60,60,...
//    58,59,59,60,60,61,...   (This one started recording in the middle of a trial)
//    ...,254,254,255,255,0,0,1,1,...

//Invalid sequences
//    58,58,59,60,60,61,61    (missed a start or stop)
//    4,4,5,5,6,6,7,3,8,8     (bit flip turned 7 into 3)

//The function attempts to fix these common problems:
// 1) Errors in code values: If a code value is incorrect due to noise on the line,
//    we simply set it to the correct value(1,1,2,42,3,3  ->  1,1,2,2,3,3)

//The function returns false if any of these conditions are met
// 1) More than one alignment code in a row is incorrect (out of sequence, bit flip, missing code)
// 2) An alignment code is missing(e.g. 1,1,3,3,4,4)
// 3) A start/stop is missing (e.g 1,1,2,3,3,4,4)
// 4) Alignment codes are out of order (e.g. 1,1,3,3,2,2,4,4)

bool AlignmentTool::processAlignmentTable(QSqlDatabase *db, QString tablename)
{
	QSqlQuery sourceQuery(*db);
	QSqlQuery destQuery(mergedDB);

	QDateTime currTime = QDateTime::currentDateTime();
	QString dateStr = currTime.date().toString("MM/dd/yyyy");
	QString timeStr = currTime.time().toString("hh:mm:ss");

	destQuery.prepare("INSERT INTO msglog (type,message,dbname,date,time) "
		"VALUES ('info','Processing alignment table',:dbname,:date,:time)");
	destQuery.bindValue(":dbname",db->connectionName());
	destQuery.bindValue(":date",dateStr);
	destQuery.bindValue(":time",timeStr);
	Q_ASSERT(destQuery.exec());

	int errCount = 0;

	//check for existence of alignment table
	if(!db->tables().contains("alignment"))
	{
		errorString = db->connectionName();
		errorString += ": does not contain an alignment table";

		destQuery.prepare("INSERT INTO msglog (type,message,dbname,date,time) " 
			"VALUES ('fatal','Table \"alignment\" not found',:dbname,:date,:time)");
		destQuery.bindValue(":dbname",db->connectionName());
		destQuery.bindValue(":date",dateStr);
		destQuery.bindValue(":time",timeStr);
		Q_ASSERT(destQuery.exec());

		return false;
	}

	//check that alignment table contains timestamp and aligncode columns
	QSqlRecord fields = db->record("alignment");
	if(!fields.contains("aligncode"))
	{
		errorString = "alignment table does not contain the \"aligncode\" field.";

		destQuery.prepare("INSERT INTO msglog (type,message,dbname,date,time) "
			"VALUES ('fatal','Table \"alignment\" does not contain the \"aligncode\" field.',:dbname,:date,:time)");
		destQuery.bindValue(":dbname",db->connectionName());
		destQuery.bindValue(":date",dateStr);
		destQuery.bindValue(":time",timeStr);
		Q_ASSERT(destQuery.exec());

		return false;
	}
	if(!fields.contains("timestamp"))
	{
		errorString = "alignment table does not contain the \"timestamp\" field.";

		destQuery.prepare("INSERT INTO msglog (type,message,dbname,date,time) "
			"VALUES ('fatal','Table \"alignment\" does not contain the \"timestamp\" field.',:dbname,:date,:time)");
		destQuery.bindValue(":dbname",db->connectionName());
		destQuery.bindValue(":date",dateStr);
		destQuery.bindValue(":time",timeStr);
		Q_ASSERT(destQuery.exec());
		return false;
	}

	//grab all of the records from the alignment table in timestamp order
	Q_ASSERT(sourceQuery.exec("SELECT id, timestamp, aligncode FROM alignment ORDER BY timestamp"));

	//Create a list of timestamps/alignment codes (in timestamp order)
	QList<double> timestampList;
	QList<int> alignmentCodeList;
	QList<int> idList;

	while(sourceQuery.next())
	{
		idList.push_back(sourceQuery.value(0).toInt());
		timestampList.push_back(sourceQuery.value(1).toDouble());
		alignmentCodeList.push_back(sourceQuery.value(2).toInt());
	}

	//If the first alignment code is a "single", delete it
	//This turns 4,5,5,6,6,7,7 into 5,5,6,6,7,7
	if(alignmentCodeList[0] != alignmentCodeList[1])
	{
		alignmentCodeList.erase(alignmentCodeList.begin());
		timestampList.erase(timestampList.begin());
		idList.erase(idList.begin());
	}

	unsigned char currCode = alignmentCodeList[0];

	//navigate through the lists looking at the pairs of alignment codes.
	for(int x=0; x+1<timestampList.size(); x+=2)
	{
		bool err = false;

		//check that the alignment codes are equal
		if(alignmentCodeList[x] != alignmentCodeList[x+1])
		{
			err = true;
			
			//if at least one of the pair isn't correct, we should give up.  This is a case
			//of mising alignment codes (1,1,2,2,4,4), or serious noise on the line (1,1,2,2,24,53,4,4)
			if(alignmentCodeList[x] != currCode && alignmentCodeList[x+1] != currCode)
			{
				errorString = QString("Alignment codes out of order. Database: %1 alignment code: %2 timestamp: %3")
						.arg(db->connectionName())
						.arg(alignmentCodeList[x])
						.arg(timestampList[x]);

				destQuery.prepare("INSERT INTO msglog (type,message,tablename,dbname,errid,date,time) "
					"VALUES ('fatal','Alignment code out of order','alignment',:dbname,:errid,:date,:time)");
				destQuery.bindValue(":dbname",db->connectionName());
				destQuery.bindValue(":errid",idList[x]);
				destQuery.bindValue(":date",dateStr);
				destQuery.bindValue(":time",timeStr);
				Q_ASSERT(destQuery.exec());

				return false;
			}
			//one of the pair is correct
			else
			{
				//check to see if the next pair is correct, and if so, we can
				//simply fix the incorrect code, under the assumption that
				//it was caused by a random bit flipping event.
				if(alignmentCodeList[x+2] == currCode+1 && alignmentCodeList[x+3] == currCode+1)
				{
					int badIdx;

					//Find the bad code
					if(alignmentCodeList[x] != currCode)
						badIdx = x;
					else
						badIdx = x+1;

					errorString = QString("Incorrect alignment code. Database: %1 alignment codes: %2 timstamps: %3.")
						.arg(db->connectionName())
						.arg(alignmentCodeList[badIdx])
						.arg(timestampList[badIdx]);
					errorString += QString(" Alignment code set to %1")
						.arg(currCode);

					//fix the error
					alignmentCodeList[badIdx] = currCode;

					destQuery.prepare("INSERT INTO msglog (type,message,tablename,dbname,errid,date,time) "
						"VALUES ('repair','Alignment code incorrect','alignment',:dbname,:errid,:date,:time)");
					destQuery.bindValue(":dbname",db->connectionName());
					destQuery.bindValue(":errid",idList[badIdx]);
					destQuery.bindValue(":date",dateStr);
					destQuery.bindValue(":time",timeStr);
					Q_ASSERT(destQuery.exec());
				}
				//If the next pair is incorrect, then we have multiple consecutive errors
				//This could be a case of a missing start/stop (1,1,2,2,3,4,4), or an extra
				//code being inserted (1,1,2,2,51,3,3)

				//check for a random code insertion and fix
				else if (alignmentCodeList[x+2] == currCode)
				{
					int badIdx;

					//Find the bad code
					if(alignmentCodeList[x] != currCode)
						badIdx = x;
					else
						badIdx = x+1;

					err = true;
					errorString = QString("Extra alignment code deleted. Database: %1 alignment code: %2 timestamp: %3")
						.arg(db->connectionName())
						.arg(alignmentCodeList[badIdx])
						.arg(timestampList[badIdx]);

					destQuery.prepare("INSERT INTO msglog (type,message,tablename,dbname,errid,date,time) "
						"('repair','Extra alignment code deleted.','alignment',:dbname,:errid,:date,:time)");
					destQuery.bindValue(":dbname",db->connectionName());
					destQuery.bindValue(":errid",idList[badIdx]);
					destQuery.bindValue(":date",dateStr);
					destQuery.bindValue(":time",timeStr);
					Q_ASSERT(destQuery.exec());


					//delete the bad code
					alignmentCodeList.removeAt(badIdx);
					timestampList.removeAt(badIdx);
					idList.removeAt(badIdx);
				}
				//If we've made it this far, we're either missing a stop/start (1,1,2,2,3,4,4)
				//or we have consecutive errors (1,1,2,2,3,51,24,4,5,5).  Either way, 
				//it's time to abort
				else
				{
					errorString = QString("Alignment codes not paired. Database: %1 alignment code: %2 timestamp: %3")
						.arg(db->connectionName())
						.arg(alignmentCodeList[x])
						.arg(timestampList[x]);

					destQuery.prepare("INSERT INTO msglog (type,message,tablename,dbname,errid,date,time) "
						"VALUES ('fatal','Alignment codes not paired.','alignment',:dbname,:errid,:date,:time)");
					destQuery.bindValue(":dbname",db->connectionName());
					destQuery.bindValue(":errid",idList[x]);
					destQuery.bindValue(":date",dateStr);
					destQuery.bindValue(":time",timeStr);
					Q_ASSERT(destQuery.exec());

					return false;
				}

			}

		}
		
		//check that the alignment codes have the correct value.  Since we already 
		//dealt with pairing, this should be really easy.
		if(alignmentCodeList[x] != currCode || alignmentCodeList[x+1] != currCode)
		{
			errorString = QString("Alignment codes paired, but have incorrect value. Database: %1 alignment code: %2 timestamp: %3")
						.arg(db->connectionName())
						.arg(alignmentCodeList[x])
						.arg(timestampList[x]);

			destQuery.prepare("INSERT INTO msglog (type,message,tablename,dbname,errid,date,time) "
				"VALUES ('fatal','Alignment codes have incorrect value','alignment',:dbname,:errid,:date,:time)");
			destQuery.bindValue(":dbname",db->connectionName());
			destQuery.bindValue(":errid",idList[x]);
			destQuery.bindValue(":date",dateStr);
			destQuery.bindValue(":time",timeStr);
			Q_ASSERT(destQuery.exec());
			return false;
		}

		if(err)
		{
			errCount++;
			qDebug()<<errorString;
		}
		currCode++;
	}

	//Now that everything is repaired (hopefully), we can write out the results to the 
	//merged database.
	if(timestampList.size() != alignmentCodeList.size() || alignmentCodeList.size() != idList.size())
	{
		errorString = "List size mismatch";
		qDebug()<<errorString;
		return false;
	}

	//create the destination database
	destQuery.exec("DROP TABLE "+tablename);
	destQuery.exec("CREATE TABLE " + tablename + " (id INTEGER PRIMARY KEY, timestamp REAL, aligncode INTEGER)");

	mergedDB.transaction();

	for(int x=0; x<idList.size(); x++)
	{
		destQuery.prepare("INSERT INTO " + tablename + " (timestamp,aligncode) "
			"VALUES (:timestamp,:aligncode)");
		destQuery.bindValue(":timestamp",timestampList[x]);
		destQuery.bindValue(":aligncode",alignmentCodeList[x]);
		Q_ASSERT(destQuery.exec());
	}

	mergedDB.commit();

	//Finally report the number of alignment codes and the number of repairs.
	QString results = QString("Processed alignment table. %1 codes, %2 errors")
		.arg(idList.size())
		.arg(errCount);

	destQuery.prepare("INSERT INTO msglog (type,message,dbname,date,time) "
		"VALUES ('info',:message,:dbname,:date,:time)");
	destQuery.bindValue(":message", results);
	destQuery.bindValue(":dbname",db->connectionName());
	destQuery.bindValue(":date",dateStr);
	destQuery.bindValue(":time",timeStr);
	Q_ASSERT(destQuery.exec());

	return true;
}

bool AlignmentTool::openDBs(QString neuralDBFilename, QString behavioralDBFilename, QString mergedDBFilename)
{
	//Open the databases
	neuralDB = QSqlDatabase::addDatabase("QSQLITE", "NeuralDB");
	neuralDB.setDatabaseName(neuralDBFilename);
	bool result = neuralDB.open();
	if(!result)
	{
		errorString = "Failed to open neural database. Error: ";
		errorString += neuralDB.lastError().text();
		return false;
	}

	behavioralDB = QSqlDatabase::addDatabase("QSQLITE", "BehavioralDB");
	behavioralDB.setDatabaseName(behavioralDBFilename);
	result = behavioralDB.open();
	if(!result)
	{
		errorString = "Failed to open behavioral database. Error: ";
		errorString += behavioralDB.lastError().text();
		return false;
	}

	mergedDB = QSqlDatabase::addDatabase("QSQLITE", "MergedDB");
	mergedDB.setDatabaseName(mergedDBFilename);
	result = mergedDB.open();
	if(!result)
	{
		errorString = "Failed to open merged database. Error: ";
		errorString += mergedDB.lastError().text();
		return false;
	}


	return true;
}

void AlignmentTool::closeDBs()
{
	neuralDB.close();
	behavioralDB.close();
	mergedDB.close();
}

void AlignmentTool::initMergedDB()
{
	QSqlQuery query(mergedDB);

	//kill the old tables
	query.exec("DROP TABLE msglog");
	query.exec("DROP TABLE trials");
	query.exec("DROP TABLE spikes");


	//create a message log table
	query.exec("CREATE TABLE msglog (id INTEGER PRIMARY KEY, type TEXT, message TEXT, "
		"tablename TEXT, dbname TEXT, errid INTEGER, date TEXT, time TEXT)");

	//create a trials table
	query.exec("CREATE TABLE trials (id INTEGER PRIMARY KEY, trialnumber INTEGER, "
		"starttime REAL, endtime REAL, duration REAL, startjitter REAL, endjitter REAL, durationjitter REAL)");

	//create a spikes table
	query.exec("create table spikes (id INTEGER PRIMARY KEY, timestamp REAL, channel TEXT, unit TEXT, waveform TEXT)");

}

// This function completes a linear least squares fitting on a pair of QList<double>
// The interesting part of the function is that rather than assuming that the lists
// are aligned, the function aligns the lists based on the passed in starting indices,
// and then stops running the alignment when it runs out of data on one of the two lists.

//The math is based on:
//  http://mathworld.wolfram.com/LeastSquaresFitting.html
//and fits to y=a+bx

void AlignmentTool::linearLeastSquares(const QList<double> &xData, const QList<double> &yData, 
									   int xIndex, int yIndex, double &a, double &b, double &corr)
{
	//SSxx = sum(x[i]^2) - n*mean(x)^2
	//SSyy = sum(y[i]^2) - n*mean(y)^2
	//SSxy = sum(x[i]y[i]) - n*mean(x)*mean(y)
	//Sx = sum(x[i])  used to calculate mean(x)
	//Sy = sum(y[i])  used to calculate mean(y)
	//n - number of points in fit

	double SSxx=0.0, SSyy=0.0, SSxy=0.0;
	double Sx=0.0, Sy=0.0;
	int n=0;

	while(xIndex != xData.size() && yIndex != yData.size())
	{
		SSxx += xData[xIndex]*xData[xIndex];
		SSyy += yData[yIndex]*yData[yIndex];
		SSxy += xData[xIndex]*yData[yIndex];

		Sx += xData[xIndex];
		Sy += yData[yIndex];

		n++;

		xIndex++;
		yIndex++;
	}

	//do the math...
	double meanX = Sx/n;
	double meanY = Sy/n;

	SSxx -= n*meanX*meanX;
	SSyy -= n*meanY*meanY;
	SSxy -= n*meanX*meanY;

	b = SSxy/SSxx;
	a = meanY - meanX*b;
	corr = (SSxy*SSxy)/(SSxx*SSyy);
}
