#ifndef ALIGNMENTTOOL_H
#define ALIGNMENTTOOL_H

#include <QList>
#include <QSqlDatabase>
#include <QSharedPointer>
#include <QMutex>

/*!	\brief Aids in the alignment of the neural and behavioral timebases
 *
 *	There are two seperate timebases in Picto.  The behavioral timebase is used
 *	to stamp the events that are recorded/generated by PictoDirector, while the
 *	neural timebase is used by the neural recording device (Plexon, TDT, etc).
 *	This object looks at the trial start/end events where are generated
 *	simultaneously in both timebases and generates a best fit which can then 
 *	be used to convert between timebases.
 *
 *	PictoDirector generates trial start/end events and stamps them with its
 *	timebase.  At approximately the same time, it sends an alignment code to
 *	the neural recording device.  The alignment code is a 7-bit value that is
 *	the same for the start and end event.  The alignment codes roll-over when
 *	they reach 127 (126,127,0,1,...), but it is assumed that the events will
 *	more or less in order, so we don't worry about misaligning events.
 *
 *	WARNING: As of Sept 2010, this tool is mostly untested.  I have no idea if
 *	it actually works.  (Hint: It probably has at least 1 bug)
 * 
 *  WARNING: Currently, the session database is being passed into the alignment
 *  calls.  This is a BAD way to do things because there should only ever be one
 *  one database associated with each alignmentTool object anyway.  Also, all 
 *  database access needs to be moved into the sessionInfo object anyway, so
 *  do that.
 */

class AlignmentTool
{
public:
	AlignmentTool();
	virtual ~AlignmentTool();

	void resetValues();
	double convertToBehavioralTimebase(double neuralTime);
	double convertToNeuralTimebase(double behavioralTime);
	double convertSamplePeriodToBehavioralTimebase(double neuralSamplePeriod);
	double convertSamplePeriodToNeuralTimebase(double behavioralSamplePeriod);
	double getJitter(double bAlignTimestamp, double nAlignTimestamp);
	double getCorrelationCoefficient();
	double getNeuralOffsetTime();
	double getNeuralTemporalFactor();
	void updateCoefficients(double bAlignTimestamp, double nAlignTimestamp);
	QString getSQLJitterEquation(	QString jitterColumn, 
									QString neuralTimebaseColumn, 
									QString behavioralTimebaseColumn,
									QString correlationColumn);

	//void doFullAlignment(QSqlDatabase& sessionDb);
	//void doIncrementalAlignment(QSqlDatabase& sessionDb);

private:
	struct AlignmentEvent
	{
		int id;
		int alignCode;
		int trialNum;
		double timestamp;
	};

	//Y = A + BX
	//Y - behavioral timebase
	//X - neural timebase
	//corr = correlation coefficient
	typedef struct 
	{
		double A;
		double B;
		double corr;
	} coefficients;

	//bool executeWriteQuery(QSqlQuery* query, QString optionalString = "");
	//bool executeReadQuery(QSqlQuery* query, QString optionalString = "");

	coefficients coeff_;

	//Fitting values
	//SumXX = sum(x[i]^2)
	//SumYY = sum(y[i]^2)
	//SumXY = sum(x[i]y[i])
	//SumX = sum(x[i])  used to calculate mean(x)
	//SumY = sum(y[i])  used to calculate mean(y)
	//n = number of points in fit
	double sumXX_, sumYY_, sumXY_;
	double sumX_, sumY_;
	int n_;

	//statistics
	int trials_;
	//QMutex* databaseWriteMutex_;
	QSharedPointer<QMutex> alignmentMutex_;
};


#endif

