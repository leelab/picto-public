#ifndef _PROPERTY_H_
#define _PROPERTY_H_

#include <QtVariantProperty.h>
#include <QVariant>
#include <QString>
#include <QMap>
#include <QXmlStreamWriter>
#include <QSharedPointer>

#include "../common.h"
#include "../storage/Asset.h"

namespace Picto {
class PropertyContainer;
/*!	\brief Describes the property of an object
 *
 *	Many objects in Picto have properties (e.g. a circle has properties of color 
 *	radius, and location).  The Property object holds this data.  Each property
 *	contains a name, a variant value and may include attributes (ie. allowable
 *	names for an enum property).  Properties may be deserialized from a picto
 *  xml file using deserializeFromXml.  Their values may also be converted to
 *	and from string form using valToUserString() and valFromUserString().  Underlying
 *  each property are 3 values.  The saveValue, the initValue and the runValue.  
 *	Properties also run in two modes, run mode and design mode.  In design mode, 
 *	all calls to setValue() write to all three values and calls to value() return
 *	the saveValue.  In run mode, calls to setValue() set the runValue and calls to
 *	value() return the runValue.  The initValue may also be set by using setInitValue()
 *	and returned from initValue().  By separating these three values in this way, we
 *  can act on the same property while designing and running, reset values during
 *	an experimental run and leave the underlying savable design untouched.  Init values
 *  are also important to keep the Picto run model intact.  Users may change init values
 *	during an experimental run, but they are only set to the underlying run values on
 *	entering a level in the state machine where they are accessible.  In some unusual
 *	cases (ie. The experiment properties of xOffset, yOffset, etc), run properties should
 *	be settable by the user even while the state machine is at a level where they are 
 *	already in scope.  For these cases, use enbleInitRunValueSync() for which case 
 *	these values are copied to one another every time they are written.
 */
#if defined WIN32 || defined WINCE
	class PICTOLIB_API Property : public Asset
#else
class Property : public Asset
#endif
{
	Q_OBJECT
public:
	virtual ~Property();
	int type();
	QString getName();
	//virtual void setValue(QVariant _value);
	void setAttribute(QString _attributeName, QVariant _attributeValue);
	QVariant attributeValue(QString _attributeName) const;
	QStringList getAttributes(){return attributes_.keys();};

	QVariant initValue();
	QVariant value();

	virtual void enableRunMode(bool enable);
	void enableInitRunValueSync(bool enable);

	//Set this property as changeable during runtime.
	void setRuntimeEditable(bool enabled = true){runtimeEnabled_ = enabled;};
	bool isRuntimeEnabled(){return runtimeEnabled_;};

	//Sets whether this property will be visible in GUI property editors.  Default is true.
	void setVisible(bool visible){visible_ = visible;};
	//Gets whether this property should be visible in GUI property editors.  Default is true.
	bool isVisible(){return visible_;};
	//Sets this property as an associate property.  This is used with read-only monitoring
	//to allow for runtime checks of whether non-experimental scripts attempt to write to experimental properties.
	void setAssociateProperty(bool isAssociate){associateProperty_ = isAssociate;};

	virtual bool serializeAsXml(QSharedPointer<QXmlStreamWriter> xmlStreamWriter);
	virtual bool deserializeFromXml(QSharedPointer<QXmlStreamReader> xmlStreamReader, bool validate);

	//This is the string that is sent over the network and written into the session database.
	QString initValToUserString();
	//This updates the property init value from a string generated by toUserString().
	void initValFromUserString(QString userString);
	//This is the string that is sent over the network and written into the session database.
	QString valToUserString();
	//This updates the property value from a string generated by toUserString().
	void valFromUserString(QString userString);

	virtual QString identifier(){return tagName_;};
	virtual QString assetType(){return "Property";};

	virtual	int getAssetId();
	virtual void setAssetId(int id);

	static bool encounteredObsoleteSerialSyntax(){return hadObsoleteSerialSyntax_;};
	static void clearObsoleteSerialSyntax(){hadObsoleteSerialSyntax_ = false;};
	
	//These functions allow picto classes to monitor whether property values were
	//changed when scripts should have been functioning in a "read only" mode.
	//To do this, a Picto element would call startMonitoringForValueChange() 
	//just before running the operator's script.  Afterward, the element can
	//check valueWasChanged() and if it was, throw a scripting error.
	//The first value to have been changed since startMonitoringForValueChange()
	//was called is available from changedValueName().
	static void startMonitoringForValueChange(){valueWasChanged_ = false;};
	static void startMonitoringForExperimentalValueChange(){expValueWasChanged_ = false;};
	static bool valueWasChanged(){return valueWasChanged_;};
	static bool experimentalValueWasChanged(){return expValueWasChanged_;};
	static QString changedValueName(){return changedValueName_;};
	static QString changedExperimentalValueName(){return changedExpValueName_;};

public slots:
	void setInitValue(QVariant _value);
	void setValue(QVariant _value);

signals:
	void initValueChanged(Property* changedProp,QVariant newInitValue);
	void valueChanged(Property* changedProp,QVariant newValue);

protected:
	Property(int type, QString name, QVariant value);

	//Converts the input variant value to a string
	virtual QString variantToString(QVariant value) const;
	//Converts the input string to a variant
	virtual QVariant stringToVariant(QString string, QString& error) const;
	//In some cases, older versions of Picto data files included tags with
	//properties and no string data.  This function builds a variant value
	//based on attributes that were serialized in.
	virtual QVariant attributeMapToVariantValue(QMap<QString,QVariant> attrMap, QString& error) const;

private:
	friend class PropertyContainer;
	QVariant saveValuePrivate();
	void setSaveValuePrivate(QVariant _value);

	QVariant initValuePrivate();
	void setInitValuePrivate(QVariant _value);

	QVariant runValuePrivate();
	void setRunValuePrivate(QVariant _value);

	//Handle XML attributes that need to be serialized in and out
	void AddSerializationAttribute(QString name);
	void SetSerializationAttributeValue(QString name, QVariant _value);
	QVariant GetSerializationAttributeValue(QString name);
	QMap<QString,QVariant> serializationAttributes_;
	void addSubProperty(QSharedPointer<Property> prop);
	void setName(QString name);
	int index_;
	bool syncInitAndRunVals_;
	bool runMode_;
	bool unsavedValsInitialized_;
	QString tagName_;
	QString tagText_;
	QString typeVal_; // In cases where a Asset Factory used a type attribute to choose between types, a type that we don't use but need to write out would be in the tag.
	bool scriptEditable_;
	bool runtimeEnabled_;
	int assetId_;
	QVariant saveValue_;
	QVariant initValue_;
	QVariant runValue_;
	int type_;
	QString name_;
	QMap<QString,QVariant> attributes_;
	bool visible_;
	bool serialSyntaxUpgraded_;
	bool associateProperty_;
	static bool hadObsoleteSerialSyntax_;
	static bool valueWasChanged_;
	static bool expValueWasChanged_;
	static QString changedValueName_;
	static QString changedExpValueName_;

//private slots:
//	void valueChanged(QtProperty *property, const QVariant &val);
//    void attributeChanged(QtProperty *property,
//                const QString &attribute, const QVariant &val);
};


}; //namespace Picto

#endif
