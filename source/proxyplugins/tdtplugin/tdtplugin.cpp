#include <windows.h>
#include <tchar.h>

#include <QString>
#include <QLineEdit>
#include <QMessageBox>
#include <QXmlStreamWriter>

#include "tdtplugin.h"
#include "dialog.h"
#include "../../common/memleakdetect.h"

/*! \brief Constructs a PlexonPlugin object.*/
TdtPlugin::TdtPlugin()
{
	deviceStatus_ = notStarted;
}

QString TdtPlugin::device() const
{
	return "TDT";
}

/*! \brief To access data from the TDT system, we need the TDT server name, and the names of the Tank and Block that
 *	to which data is currently being written.  This function gets that data and stores it.
 *	\details In the general case, the Proxy application runs on the same computer as the TDT Server,
 *	in this case, the "local" name can be used for the tdt server.  To get the names of the Tank and the currently running
 *	Block, we run through all available tanks and use the TDT API to check each one for a running block with
 *	TTANKXLib::_DTTankXPtr::GetHotBlock().  When we find the "HotBlock" we store it and its Tank.
 *	In the case where DEVELOPMENTBUILD is defined, the Proxy application needn't run on the TDT Server computer.  We get 
 *	the name of the TDT Server from a dialog and then use that to access the server and get the active Block/Tank.  
 *	In either case, if we fail to find an active block we return false, otherwise we return true.
 */
bool TdtPlugin::getRunningBlockInfo()
{
	QString serverName = "local";
	#ifdef DEVELOPMENTBUILD
	//get the server/tank/block name
	Dialog *getServerInfo = new Dialog();
	getServerInfo->exec();
	serverName = getServerInfo->serverLine->text();
	#endif

	//convert everything from QString to wchar_t*
	//This is ugly....
	szServerName = new wchar_t[serverName.size()+1];
	serverName.toWCharArray(szServerName);
	szServerName[serverName.size()] = '\0';

	szTankName = _bstr_t("");

	szBlockName = _bstr_t("");

	//Test the tank Interface to make sure that the passed in values are working.
	QMessageBox errorMsgBox;

	HRESULT hr;
	hr = CoInitialize(NULL);
	if (FAILED(hr)) {
		errorMsgBox.setText(tr("COM failed to initialize"));
		errorMsgBox.exec();
		return false;
	}
	hr = tdtTank.CreateInstance("TTank.X"); //appId = "{670490CE-57D2-4176-8E74-80C4C6A47D88}"; //"TTankX.ocx"

	if (FAILED(hr)) {
		CoUninitialize();
		errorMsgBox.setText(tr("Couldn't start the TDT interface. Are the TDT ActiveX controls installed?"));
		errorMsgBox.exec();
		return false;
	}

	try
	{
		if(!(tdtTank->ConnectServer(szServerName,"PictoProxyServer")))
		{
			CoUninitialize();
			errorMsgBox.setText(tr("Couldn't connect to TDT server: %1").arg(serverName));
			errorMsgBox.exec();
			return false;
		}
	}
	catch(_com_error e)
	{
		CoUninitialize();
		// Crack _com_error
		_bstr_t bstrSource(e.Source());
		QString qstSource((char*) bstrSource);

		_bstr_t bstrDescription(e.Description());
		QString qstDescription((char*) bstrDescription);

		QString qstErrorMessage(e.Error());

		errorMsgBox.setText(tr("Exception thrown for classes generated by #import"));
		errorMsgBox.setInformativeText(tr("Code = %1\nCodeMeaning = %2\n"
									"Source = %3\nDescription =%4\n").
									arg(e.Error()).
									arg(qstErrorMessage).
									arg(qstSource).
									arg(qstDescription));
		errorMsgBox.exec();
		return false;
	}

	//Find the active tank and block

	//Loop through all the tanks on the server.
	int i=0;
	_bstr_t tank;
	_bstr_t hotBlock;
	bool successfulSelection = false;
	while(true)
	{
		tank = tdtTank->GetEnumTank(i);
		if(tank == _bstr_t(""))
			break;
		//Connect to this tank.
		if(tdtTank->OpenTank(tank,"R"))
		{
			//We opened the tank.
			//Check if this tank contains a "hot block" (a currently running block)
			hotBlock = tdtTank->GetHotBlock();
			if(hotBlock != _bstr_t(""))
			{
				//We found the hot block. Select it.
				if(tdtTank->SelectBlock(hotBlock))
				{	//We succefully selected the hot block.  Break.
					successfulSelection = true;
					tdtTank->CloseTank();
					break;
				}
			}
			tdtTank->CloseTank();
		}
		i++;
	}

	//Make sure we found a hot block
	if(!successfulSelection)
	{
		tdtTank->ReleaseServer();
		CoUninitialize();
		errorMsgBox.setText(tr("Could not select a running tdt block"));
		errorMsgBox.exec();
		return false;
	}
	if(hotBlock == _bstr_t("TempBlk"))
	{
		tdtTank->ReleaseServer();
		CoUninitialize();
		successfulSelection = false;
		errorMsgBox.setText(tr("TDT system does not appear to be recording."));
		errorMsgBox.exec();
		return false;
	}
	
	szTankName = tank.copy();
	szBlockName = hotBlock.copy();
	sampleRate=0;
	lastEventTimestamp_ = 0;
	lastSpikeTimestamp_ = 0;
	lastLFPTimestamp_ = 0;

	//Close everything back up...
	tdtTank->ReleaseServer();
	CoUninitialize();
	return true;
}

/*! \brief Attempts to open the Tank and Block discovered in getRunningBlockInfo() through the COM interface,
 *	returns true on success, false otherwise.
 */
bool TdtPlugin::startCOM()
{
	if(deviceStatus_ > notStarted)
		return true;
	
	//set up the connection
	//Initialize ActiveX object
	HRESULT hr;
	hr = CoInitialize(NULL);
	if (FAILED(hr)) {
		return false;
	}
	hr = tdtTank.CreateInstance("TTank.X"); //appId = "{670490CE-57D2-4176-8E74-80C4C6A47D88}"; //"TTankX.ocx"

	if (FAILED(hr)) 
	{
		
		return false;
	}

	try
	{
		if(!(tdtTank->ConnectServer(szServerName,"PictoProxyServer")))
		{
			
			return false;
		}
	}
	catch(_com_error e)
	{
		
		return false;
	}

	if(!(tdtTank->OpenTank(szTankName,"R")))
	{
		tdtTank->ReleaseServer();
		
		return false;
	}

	if(!(tdtTank->SelectBlock(szBlockName)))
	{
		tdtTank->CloseTank();
		tdtTank->ReleaseServer();
		
		return false;
	}
	return true;
}

/*! \brief Closes resources that were opened in startCOM().*/
void TdtPlugin::stopCOM()
{
	if(deviceStatus_ == notStarted)
		return;
	tdtTank->CloseTank();
	tdtTank->ReleaseServer();
	CoUninitialize();
	
}


NeuralDataAcqInterface::deviceStatus TdtPlugin::startDevice()
{
	if(getRunningBlockInfo())
	{
		sampleRate = 0.0f;
		lastEventTimestamp_ = 0;
		lastSpikeTimestamp_ = 0;
		lastLFPTimestamp_ = 0;
		lfpData_.clear();
		if(startCOM())
			deviceStatus_ = started;
	}

	return deviceStatus_;
}

NeuralDataAcqInterface::deviceStatus TdtPlugin::stopDevice()
{
	stopCOM();
	sampleRate = 0.0f;
	deviceStatus_ = notStarted;
	lfpData_.clear();
	return deviceStatus_;
}
NeuralDataAcqInterface::deviceStatus TdtPlugin::getDeviceStatus()
{
	if(deviceStatus_ > notStarted)
	{
		long tankStatus = tdtTank->CheckTank(szTankName);
		if(tankStatus != 79 && tankStatus != 82)
		{
			deviceStatus_ = noData;
		}
		else
		{
			deviceStatus_ = hasData;
		}
	}
	return deviceStatus_;
}

float TdtPlugin::samplingRate()
{
	//The sample rate is zeroed any time the device is stopped or started.
	//The rate is also updated every time dump data is called.
	//Since the sampling rate shouldn't be changing during a run, then 
	//if it isn't zero, we can jsut use the value from the last call to dump data.
	if(sampleRate != 0.0f)
		return sampleRate;

	if(deviceStatus_ == notStarted)
		return 0;
	
	long tankStatus = tdtTank->CheckTank(szTankName);
	if(tankStatus != 79 && tankStatus != 82)
	{
		return 0;
	}

	int numSpikeSamples;

	//Read spike samples
	//NOTE: The name of this event stream was changed somewhere along the line from "Snip" to "eNeu".  To read some of Hiroshi's old data, you
	//may need to change it back to Snip
	numSpikeSamples = tdtTank->ReadEventsV(1000000,"eNeu",0,0,0.0,0.0,"All");
	
	_variant_t spikeSampleFrequencyArray;

	spikeSampleFrequencyArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,9);
	
	sampleRate = (float)((double *) spikeSampleFrequencyArray.parray->pvData)[0];
	return sampleRate;
}

QList<QSharedPointer<Picto::DataUnit>> TdtPlugin::dumpData()
{
	QList<QSharedPointer<Picto::DataUnit>> returnList;
	QSharedPointer<Picto::NeuralDataUnit> neuralData;
	QSharedPointer<Picto::AlignmentDataUnit> alignData;
	if(deviceStatus_ == notStarted)
	{
		return returnList;
	}

	long tankStatus = tdtTank->CheckTank(szTankName);
	if(tankStatus != 79 && tankStatus != 82)
	{
		//TDT Tank not open.
		return returnList;
	}

	int numSpikeSamples;
	//double readUntilTime = 0.0;
	QVector<SpikeDetails> spikeList;
	QVector<EventDetails> eventList;

	//Read spike samples
	//NOTE: The name of this event stream was changed somewhere along the line from "Snip" to "eNeu".  To read some of Hiroshi's old data, you
	//may need to change it back to Snip
	numSpikeSamples = tdtTank->ReadEventsV(1000000,"eNeu",0,0,lastSpikeTimestamp_,0.0,"All");

#ifdef DEVELOPMENTBUILD
	//This is really only used in simulations where we are pulling data from a tank that
	//is already full.  We do this to avoid taking forever to respond.
	if(numSpikeSamples >1000)
		numSpikeSamples = 1000;
#endif

	//load spike samples
	_variant_t spikeSampleArray, spikeTimestampArray, spikeChannelArray, spikeUnitArray, spikeSampleFrequencyArray;

	if(numSpikeSamples > 0)
	{
		spikeSampleArray = tdtTank->ParseEvV(0,numSpikeSamples);
		spikeTimestampArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,6);
		spikeChannelArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,4);
		spikeUnitArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,5);
		spikeSampleFrequencyArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,9);

		sampleRate = (float)((double *) spikeSampleFrequencyArray.parray->pvData)[0];
		samplePeriod = (sampleRate != 0.0)?(1.0/sampleRate):0.0;
	}

	double nextReadTimestamp = lastSpikeTimestamp_;
	for(int i=0;i<numSpikeSamples;i++)
	{
		SpikeDetails spikeDetails;

		spikeDetails.timeStamp = ((double *) spikeTimestampArray.parray->pvData)[i];
		spikeDetails.unitNum = (int) ((double *) spikeUnitArray.parray->pvData)[i];
		spikeDetails.resolution = (float)((double *) spikeSampleFrequencyArray.parray->pvData)[i];
		if(spikeDetails.resolution > 0.0)
			spikeDetails.resolution = 1.0/spikeDetails.resolution;
		if(spikeDetails.unitNum > 0)
		{
			spikeDetails.chanNum = (int) ((double *) spikeChannelArray.parray->pvData)[i];
			if(spikeDetails.timeStamp <= lastSpikeTimestamp_)
			{	//Since TDT reads events with timestamps >= t1 and < t2, we have to just cut out
				//all of the events that occured at t1 every time.
				continue;
			}
			for(unsigned int j=0;j<spikeSampleArray.parray->rgsabound[1].cElements;j++)
			{
				float spikeVoltage = ((float *) spikeSampleArray.parray->pvData)[i*spikeSampleArray.parray->rgsabound[1].cElements+j];

				spikeDetails.sampleWaveform.append(spikeVoltage);
			}
			spikeList.append(spikeDetails);
		}
		if(spikeDetails.timeStamp > nextReadTimestamp)
			nextReadTimestamp = spikeDetails.timeStamp;
	}
	lastSpikeTimestamp_ = nextReadTimestamp;



	//Read event codes
	int numEvents;
	numEvents = tdtTank->ReadEventsV(1000000,"Evnt",0,0,lastEventTimestamp_,0.0,"ALL");
	qDebug("Got event codes");

#ifdef DEVELOPMENTBUILD
	//This is really only used in simulations where we are pulling data from a tank that
	//is already full.  We do this to avoid taking forever to respond.
	if(numEvents >1000)
		numEvents = 1000;
#endif

	_variant_t eventCodeArray, eventTimestampArray;

	if(numEvents > 0)
	{
		eventCodeArray = tdtTank->ParseEvV(0,numEvents);
		eventTimestampArray = tdtTank->ParseEvInfoV(0,numEvents,6);
	}



	//load event codes
	nextReadTimestamp = lastEventTimestamp_;
	for(int i=0; i<numEvents; i++)
	{
		EventDetails eventDetails;
		eventDetails.timeStamp = ((double *) eventTimestampArray.parray->pvData)[i];
		eventDetails.code = (int) ((double *) eventCodeArray.parray->pvData)[i];
		if(eventDetails.timeStamp <= lastEventTimestamp_)
		{	//Since TDT reads events with timestamps >= t1 and < t2, we have to just cut out
			//all of the events that occured at t1 every time.
			continue;
		}
		eventList.append(eventDetails);
		if(eventDetails.timeStamp > nextReadTimestamp)
			nextReadTimestamp = eventDetails.timeStamp;
	}
	lastEventTimestamp_ = nextReadTimestamp;


	//Read lfp codes
	int numLFP;
	numLFP = tdtTank->ReadEventsV(1000000,"LDec",0,0,lastLFPTimestamp_,0.0,"ALL");

#ifdef DEVELOPMENTBUILD
	//This is really only used in simulations where we are pulling data from a tank that
	//is already full.  We do this to avoid taking forever to respond.
	if(numLFP >1000)
		numLFP = 1000;
#endif

	_variant_t lfpSampleArray, lfpChannelArray, lfpTimestampArray, lfpFreqArray;
	if(numLFP > 0)
	{
		lfpSampleArray = tdtTank->ParseEvV(0,numLFP);
		lfpChannelArray = tdtTank->ParseEvInfoV(0,numLFP,4);
		lfpTimestampArray = tdtTank->ParseEvInfoV(0,numLFP,6);
		lfpFreqArray = tdtTank->ParseEvInfoV(0,numLFP,9);



		//load lfp codes
		//They are returned in lfpSampleArray as an 2D array, where each column
		//corresponds to a timestamp/channel in the timestamp/channel arrays, and
		//each row corresponds to a new time = columntimestamp + 1/freqArray value.

		double sampPerSec;
		double secPerSamp;
		double incomingTime;
		//double* potentials;
		int currChan;
		int sampsPerChanEntry = lfpSampleArray.parray->rgsabound[1].cElements;

		bool nextReadTimestampSet = false;
		for(int i=0; i<numLFP; i++)
		{
			//Get the channel at this index of the returned array
			currChan = (int) ((double *) lfpChannelArray.parray->pvData)[i];

			//lfpData_ is sized such that each channel number can be placed in its index.  
			//If its not big enough.  Resize it.
			if(lfpData_.size() < currChan)
			{
				lfpData_.resize(currChan+1);
			}

			//Get the next timestamp, "samples per second" and "seconds per sample"
			incomingTime = ((double *) lfpTimestampArray.parray->pvData)[i];
			sampPerSec = ((double *) lfpFreqArray.parray->pvData)[i];
			secPerSamp = 1.0/sampPerSec;
			
			//Loop through the list of "sec per sample" separated enties for the current channel adding
			//them to the LFPDataUnitPackage
			for(int j=0;j<sampsPerChanEntry;j++)
			{	
				//Make sure that the latest read time is greater than the last time that we recorded data for.
				if(incomingTime > lfpData_[currChan].currTime)
				{
					lfpData_[currChan].currTime = incomingTime;
					//If the current channel's index in lfpData_ has no lfppackage, make a new one.
					if(lfpData_[currChan].lfpPackage.isNull())
					{
						lfpData_[currChan].lfpPackage = QSharedPointer<Picto::LFPDataUnitPackage>(new Picto::LFPDataUnitPackage());
						lfpData_[currChan].lfpPackage->setChannel(currChan);
						lfpData_[currChan].lfpPackage->setResolution(secPerSamp);
						lfpData_[currChan].lfpPackage->setTimestamp(lfpData_[currChan].currTime);
					}

					//Add the next data point to the lfppackage
					lfpData_[currChan].lfpPackage->appendData(((short *) lfpSampleArray.parray->pvData)[(i*sampsPerChanEntry)+j]);

					//If the current channel's lfppackage is big enough.  (ie. on the next entry it will include over 500 ms of data)
					//Add it to the list and clear the pointer to it from lfpData_
					if((lfpData_[currChan].lfpPackage->numSamples()*secPerSamp) >= 0.5)
					{
						returnList.push_back(lfpData_[currChan].lfpPackage);
						lfpData_[currChan].lfpPackage.clear();
					}
				}
				
				//Increment the currTime value for the next sample.
				incomingTime += secPerSamp;
			}

			//TDT reads from times >= the input starting time in ReadEventsV.
			if(sampsPerChanEntry && (!nextReadTimestampSet || (lfpData_[currChan].currTime < nextReadTimestamp)))
			{
				nextReadTimestamp = lfpData_[currChan].currTime;
				nextReadTimestampSet = true;
			}
		}
		if(nextReadTimestampSet)
			lastLFPTimestamp_ = nextReadTimestamp;
	}












	//if we don't care about order, we could have output everyhting as we went.  
	//However, everthing will have to get sorted sooner or later.  We'll do a stable
	//sort on the event list and spike list, then we'll interleave the whole mess
	//generating XML as we go

	qStableSort(spikeList.begin(),spikeList.end(),spikeTimestampLessThan);
	qStableSort(eventList.begin(),eventList.end(),eventTimestampLessThan);

	//record the last timestamp
	//(This is annoying because calling last on an empty QList crashes things)
	//double lastEventTimestamp = eventList.isEmpty()?lastTimestamp: eventList.last().timeStamp;
	//double lastSpikeTimestamp = spikeList.isEmpty()?lastTimestamp: spikeList.last().timeStamp;

	while(spikeList.size() || eventList.size())
	{
		//output a spike waveform
		if(spikeList.size() && (!eventList.size() || (spikeList.begin()->timeStamp <= eventList.begin()->timeStamp)))
		{
			neuralData = QSharedPointer<Picto::NeuralDataUnit>(new Picto::NeuralDataUnit());
			neuralData->setTimestamp(spikeList.begin()->timeStamp);
			neuralData->setChannel(spikeList.begin()->chanNum);
			neuralData->setUnit(spikeList.begin()->unitNum);
			neuralData->setResolution(spikeList.begin()->resolution);

			//waveform data
			QSharedPointer<QVector<float>> waveform(new QVector<float>);
			for(int i=0; i<spikeList.begin()->sampleWaveform.size(); i++)
			{
				waveform->push_back(spikeList.begin()->sampleWaveform[i]);
			}
			neuralData->setWaveform(waveform);
			returnList.push_back(neuralData);

			//remove the just processed spike
			spikeList.erase(spikeList.begin());
		}
		//output an eventcode
		else if(eventList.size() && (!spikeList.size() || (eventList.begin()->timeStamp < spikeList.begin()->timeStamp)))
		{
			alignData = QSharedPointer<Picto::AlignmentDataUnit>(new Picto::AlignmentDataUnit());
			alignData->setTimestamp(eventList.begin()->timeStamp);
			alignData->setAlignCode(eventList.begin()->code);

			returnList.push_back(alignData);
			//remove the just processed event
			eventList.erase(eventList.begin());
			qDebug(QString("Timestamp: %1, Code: %2").arg(alignData->getTimestamp()).arg(alignData->getAlignCode()).toLatin1());
		}
	}
	return returnList;
}

bool TdtPlugin::acqDataAfterNow()
{
	dumpData();
	return true;
}

/*! \brief This is a comparison function for easy sorting of SpikeDetails structs according
 *	to time.
*/
bool TdtPlugin::spikeTimestampLessThan(const SpikeDetails &sd1, const SpikeDetails &sd2)
{
	return sd1.timeStamp < sd2.timeStamp;
}

/*! \brief This is a comparison function for easy sorting of EventDetails structs according
 *	to time.
 */
bool TdtPlugin::eventTimestampLessThan(const EventDetails &ed1, const EventDetails &ed2)
{
	return ed1.timeStamp < ed2.timeStamp;
}

//Q_EXPORT_PLUGIN2(ProxyPluginTDT, TdtPlugin)