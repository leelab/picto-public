/*! \file plexonplugin.cpp
 * \ingroup proxypluginplexon
 * \brief A plugin allowing the proxy server to interface with a Plexon MAP
 */

#include <windows.h>
#include <tchar.h>

#include <QString>
#include <QLineEdit>

#include "tdtplugin.h"
#include "dialog.h"


QString TdtPlugin::device() const
{
	return "TDT";
}

NeuralDataAcqInterface::deviceStatus TdtPlugin::startDevice()
{
	//get the server/tank/block name
	/*Dialog *getServerInfo = new Dialog();
	getServerInfo->exec();

	QString serverName = getServerInfo->serverLine->text();
	QString tankName = getServerInfo->serverLine->text();
	QString blockName = getServerInfo->blockLine->text();

	QMessageBox errorMsgBox;
	
	//set up the connection
	//Initialize ActiveX object
	HRESULT hr;
	hr = CoInitialize(NULL);
	if (FAILED(hr)) {
		errorMsgBox.setText(tr("COM failed to initialize"));
		errorMsgBox.exec();
		return NeuralDataAcqInterface::failedToStart;
	}
	hr = tdtTank.CreateInstance("TTank.X"); //appId = "{670490CE-57D2-4176-8E74-80C4C6A47D88}"; //"TTankX.ocx"

	if (FAILED(hr)) {
		errorMsgBox.setText(tr("Couldn't start the TDT interface. Are the TDT ActiveX controls installed?"));
		errorMsgBox.exec();
		return NeuralDataAcqInterface::failedToStart;
	}

	try
	{
		
		if(!(tdtTank->ConnectServer(serverName,"PictoProxyServer")))
		{
			errorMsgBox.setText(tr("Couldn't connect to TDT server: %1").arg(serverName));
			errorMsgBox.exec();
			return NeuralDataAcqInterface::failedToStart;
		}
	}
	catch(_com_error e)
	{
		 // Crack _com_error
         _bstr_t bstrSource(e.Source());
         _bstr_t bstrDescription(e.Description());

		errorMsgBox.setText(tr("Exception thrown for classes generated by #import"));
		errorMsgBox.setInformativeText(tr("Code = %1\nCodeMeaning = %2\n"
									"Source = %3\nDescription =%4\n").
									arg(e.Error()).
									arg(e.ErrorMessage()).
									arg((LPCTSTR) bstrSource).
									arg((LPCTSTR) bstrDescription));
		errorMsgBox.exec();
		return NeuralDataAcqInterface::failedToStart;
	}

	if(!(tdtTank->OpenTank(tankName,"R")))
	{
		errorMsgBox.setText(tr("Couldn't open the tank: %1").arg(tankName));
		errorMsgBox.exec();
		tdtTank->ReleaseServer();
		return NeuralDataAcqInterface::failedToStart;
	}

	if(!(tdtTank->SelectBlock(blockName)))
	{
		errorMsgBox.setText(tr("Couldn't select block: %1").arg(blockName));
		errorMsgBox.exec();
		tdtTank->CloseTank();
		tdtTank->ReleaseServer();
		return NeuralDataAcqInterface::failedToStart;
	}

	samplingRate=0;*/

	return NeuralDataAcqInterface::started;
}

NeuralDataAcqInterface::deviceStatus TdtPlugin::stopDevice()
{
	/*tdtTank->CloseTank();
	tdtTank->ReleaseServer();
	CoUninitialize();*/


	return NeuralDataAcqInterface::stopped;
}
NeuralDataAcqInterface::deviceStatus TdtPlugin::getDeviceStatus()
{
	/*long tankStatus = tdtTank->CheckTank();
	if(tankStatus == 79 || tankStatus == 82)
		return NeuralDataAcqInterface::running;*/
	return NeuralDataAcqInterface::stopped;

}


float TdtPlugin::samplingRate()
{
	//This gets thet "data rate"
	//(number of bytes stored to tank per second)
	//return samplingRate;
	return 0;
}

QString TdtPlugin::dumpData()
{
	/*QString xmlData;
	QXmlStreamWriter writer(&xmlData);

	writer.setAutoFormatting(true);

	long tankStatus = tdtTank->CheckTank();
	if(tankStatus != 79 && tankStatus != 82)
	{
		return QString::null;
	}

	int numSpikeSamples;

	//Read spike samples
	numSpikeSamples = tdtTank->ReadEventsV(1000000,"Snip",0,0,0.0,0.0,"All");
	
	printf("Read %d spike samples\n",numSpikeSamples);

	_variant_t spikeSampleArray, spikeTimestampArray, spikeChannelArray, spikeUnitArray, spikeSampleFrequencyArray;

	spikeSampleArray = tdtTank->ParseEvV(0,numSpikeSamples);
	spikeTimestampArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,6);
	spikeChannelArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,4);
	spikeUnitArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,5);
	spikeSampleFrequencyArray = tdtTank->ParseEvInfoV(0,numSpikeSamples,9);

	//Read event codes
	int numEvents;
	numEvents = tdtTank->ReadEventsV(1000000,"Evnt",0,0,0.0,0.0,"All");

	printf("Read %d Orion event codes\n",numEvents);

	_variant_t eventCodeArray, eventTimestampArray;

	eventCodeArray = tdtTank->ParseEvV(0,numEvents);
	eventTimestampArray = tdtTank->ParseEvInfoV(0,numEvents,6);


	//load spike samples
	samplingRate = (float)((double *) spikeSampleFrequencyArray.parray->pvData)[0];

	for(int i=0;i<numSpikeSamples;i++)
	{
		SpikeDetails spikeDetails;

		spikeDetails.chanNum = (int) ((double *) spikeChannelArray.parray->pvData)[i];
		spikeDetails.unitNum = (int) ((double *) spikeUnitArray.parray->pvData)[i] + 1;
		
		spikeDetails.timeStamp = (int) (0.5 + ticksPerSecond * ((double *) spikeTimestampArray.parray->pvData)[i]);
		for(unsigned int j=0;j<spikeSampleArray.parray->rgsabound[1].cElements;j++)
		{
			double spikeVoltage = ((float *) spikeSampleArray.parray->pvData)[i*spikeSampleArray.parray->rgsabound[1].cElements+j];

			spikeDetails.sampleWaveform.append(spikeVoltage);
		}
		spikeList.append(spikeDetails);
	}

	//load event codes
	for(int i=0; i<numEvents; i++)
	{
		EventDetails eventDetails;
		eventDetails.timeStamp = (int) (0.5 + ticksPerSecond * ((double *) spikeTimestampArray.parray->pvData)[i]);
		eventDetails.code = (int) ((double *) eventCodeArray.parray->pvData)[i];

		eventList.append(eventDetails);
	}


	//if we don't care about order, we could have output everyhting as we went.  
	//However, everthing will have to get sorted sooner or later.  We'll do a stable
	//sort on the event list and spike list, then we'll interleave the whole mess
	//generating XML as we go

	qStableSort(spikeList.begin,spikeList.end(),spikeTimesampLessThan);
	qStableSort(eventList.begin,eventList.end(),eventTimestampLessThan);

	//number of events
	writer.writeStartElement("numEvents");
	writer.writeCharacters(QString("%1").arg(NumMAPEvents));
	writer.writeEndElement();

	while(spikeList.size != 0 && eventList.size !=0)
	{
		//output a spike waveform
		if(spikeList.begin().timeStamp < eventList.begin().timeStamp)
		{
			writer.writeStartElement("event");

			writer.writeStartElement("timestamp");
			writer.writeCharacters(QString("%1").arg(spikeList.begin().timeStamp));
			writer.writeEndElement();

			writer.writeStartElement("eventType");
			writer.writeCharacters("spike");
			writer.writeEndElement();

			writer.writeStartElement("channel");
			writer.writeCharacters(QString("%1").arg(spikeList.begin().chanNum));
			writer.writeEndElement();

			writer.writeStartElement("unit");
			writer.writeCharacters(QString("%1").arg(spikeList.begin().unitNum));
			writer.writeEndElement();

			//waveform data
			writer.writeStartElement("wave");
			for(int i=0; i<spikeList.begin().sampleWaveform.size(); i++)
			{
				writer.writeCharacters(QString("%1 ").arg(spikeList.begin().sampleWaveform[i]));
			}
			writer.writeEndElement();
			
			writer.writeEndElement(); //end event

			//remove the just processed spike
			spikeList.erase(begin());
		}
		//output an eventcode
		else if(eventList.begin().timeStamp < spikeList.begin().timeStamp)
		{
			writer.writeStartElement("event");

			writer.writeStartElement("timestamp");
			writer.writeCharacters(QString("%1").arg(eventList.begin().timeStamp));
			writer.writeEndElement();

			writer.writeStartElement("eventType");
			writer.writeCharacters("external event");
			writer.writeEndElement();

			writer.writeStartElement("eventCode");
			writer.writeCharacters(QString("%1").arg(eventList.begin().code));
			writer.writeEndElement();

			writer.writeEndElement(); //event

			//remove the just processed event
			eventList.erase(begin());


		}
	}

	return xmlData;*/
	return "TDT datadump";
}

//comparison functions for easy sorting
/*bool spikeTimestampLessThan(const SpikeDetails &sd1, const SpikeDetails &sd2)
{
	return sd1.timeStamp < sd2.timeStamp;
}

bool eventTimestampLessThan(const EventDetails &ed1, const EventDetails &ed2)
{
	return ed1.timeStamp < ed2.timeStamp;
}*/

Q_EXPORT_PLUGIN2(ProxyPluginTDT, TdtPlugin)