<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Picto: First Look At Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="pictodoc.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Picto
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Picto Developer&#39;s Guide</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">First Look At Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Becoming familiar with a new code base is always a challenge, and Picto is no exception. To help with this process, we have spent a great deal of time documenting Picto to the functional level. At this point, every funciton in Picto should be documented, as should all variables in the protected or public scope. Even with all of this information, you will need some guidance to get started. The purpose of this file is to provide some guidelines for getting started with the code base on your way to developing a deeper familiarity with it.</p>
<h1><a class="anchor" id="first_look_disclaimer"></a>
Disclaimer</h1>
<p>As one of the key elements in gaining an understanding of source code, we will start with a few key points about the Picto documentation of which you should be aware. First, keep in mind that we went over the entire code base in 12/2013-1/2014 to make sure that all function and class documentation was up to date. This projects was my (Joey's) last project in Picto and for that reason, in the interest of not braking something at the last minute, I was very careful to not change any actual code as I went through the process. This means that you will see lots of lines of documentation saying things like: "This is not used and you should probably remove it." Sometimes the suggested changes are trivially easy, but in keeping with my "no changes" rule, I didn't change anything.</p>
<p>There are also some naming conventions that you should keep in mind in Picto. Typically, the person running an Experiment from the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a> is called the "Operator." The person or animal being examined is called the "Test Subject", "Subject" or sometimes but infrequently "User." When we are talking about parts of the Workstation like the <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> or <a class="el" href="class_test_viewer.html" title="This allows designers to run the Experiment/Analysis that they are creating in a test environment for...">TestViewer</a>, the researcher previously referred to as "Operator" might be referred to as the User (sorry, I know that is confusing). Also, sometimes that person is referred to as the "designer" since they designed the Experiment/Analysis. This can be a source of confusion due to the existance of a <a class="el" href="class_designer.html" title="A Graphical State Machine Integrated Development Environment for creating Picto Experiments and Analy...">Designer</a> class in the Picto source which is essentially the tool that the "designer person" uses to do the designing. Lastly, the actual Experiment/Analysis thing is often referred to as the Picto Design. This can be confusing because there is no actual Design class. When we say this, we are essentially referring to the root of the Experiment/Analysis tree. This is really the <a class="el" href="class_picto_1_1_picto_data.html" title="The root node of the Picto design tree. ">Picto::PictoData</a> class. One might think of the <a class="el" href="class_picto_1_1_design_root.html" title="The root of the Experiment/Analysis Design tree passed between different UI Viewers. ">Picto::DesignRoot</a> as the "Design" as well; however, the <a class="el" href="class_picto_1_1_design_root.html" title="The root of the Experiment/Analysis Design tree passed between different UI Viewers. ">Picto::DesignRoot</a> is really more of a wrapper for the <a class="el" href="class_picto_1_1_picto_data.html" title="The root node of the Picto design tree. ">Picto::PictoData</a> class. Hopefully, that will clarify some of the confusing terminology. Ideally we would have a Proof Editor that would go through all this documentation and normalize everything, but we don't and it would be quite a big job, so these types of things crop in. Also, keep in mind that Visual Studio completely rediculously has no built in spell-checker option even for comments :).</p>
<h1><a class="anchor" id="first_look_structure"></a>
Structure</h1>
<p>Picto consists of four main applications, the Workstation, <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a>, <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> and Proxy plus a sort of sub-application, the EmbeddedFrontPanel application that controls the front panel and buttons on the Pictobox. All of these projects are defined within their own Visual Studio project files (.vcxproj) in their own sub-directories of the Picto\src directory and included as part of the Picto.sln. The Visual Studio projects themselves are built by using </p><div class="fragment"><div class="line">ConfigureX86.cmd</div>
<div class="line">tools\qt.config\mypaths.cmd</div>
<div class="line">tools\win.common\GenerateBuildFiles.cmd</div>
</div><!-- fragment --><p> in the Visual Studio Command Prompt (See <a class="el" href="build_environment_preparation.html">Create a Picto Development Environment</a> for more details). The GenerateBuildFiles.cmd itself uses the various .pro files scattered around the picto/src directory tree to figure out how to build the .vcxproj files. In this vain, be aware that whenever you want to add a file to one of the Picto projects, you need to do it by adding the header and cpp files to that project's .pro file and then rerunning the scripts outlined above.</p>
<p>As far as the individual Picto applications go, different approaches may be taken in building a familiarity with each one. We go through tips for starting out with each of the application code bases below.</p>
<h1><a class="anchor" id="first_look_Workstation"></a>
Workstation</h1>
<p>Execution of the Workstation starts at the main method in <a class="el" href="workstation_2main_8cpp.html" title="The Workstation application. ">workstation\main.cpp</a>, but the <a class="el" href="mainwindow_8cpp_source.html">MainWindow.cpp</a> is what really manages the main Workstation window. Start by looking at MainWindow::createViewers() and MainWindow::changeMode(), these functions will give you as sense of how navigation works within the <a class="el" href="class_main_window.html" title="The main window for the Workstation app. ">MainWindow</a>. After that familiarize yourself with some of the other <a class="el" href="class_main_window.html" title="The main window for the Workstation app. ">MainWindow</a> functions, then move onto the classes that extend <a class="el" href="class_viewer.html" title="A Viewer is a base class for panels in the Workstation that are used to handle some clearly defined j...">Viewer</a>, namely <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a>, <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a>, <a class="el" href="class_state_edit_viewer.html" title="The StateEditViewer is a container for the Designer widget which is a development environment for cre...">StateEditViewer</a>, and <a class="el" href="class_test_viewer.html" title="This allows designers to run the Experiment/Analysis that they are creating in a test environment for...">TestViewer</a>, and work down from there. In particular, before working your way down to far, you will need to have a good sense of the Design Tree structure. Look at <a class="el" href="class_picto_1_1_serializable.html" title="The top level class of the Picto Design class hierarchy, and the Picto network transferrable data hie...">Picto::Serializable</a>, <a class="el" href="class_picto_1_1_asset.html" title="The base class for all elements of a Picto experiment/analysis design. ">Picto::Asset</a> and <a class="el" href="class_picto_1_1_data_store.html" title="A base class for all Asset objects that can have children. ">Picto::DataStore</a> to get a sense of how serialization works. Take a look at <a class="el" href="class_picto_1_1_property.html" title="Describes the property of a DataStore. ">Picto::Property</a> and <a class="el" href="class_picto_1_1_property_container.html" title="A container that groups together a set of Property objects. ">Picto::PropertyContainer</a> to understand where data is stored within <a class="el" href="class_picto_1_1_data_store.html" title="A base class for all Asset objects that can have children. ">Picto::DataStore</a> objects at its lowest level. Next, start at <a class="el" href="class_picto_1_1_experiment.html" title="The Experiment object contains the complete definition of an Experiment for running in the Director...">Picto::Experiment</a> and work your way down through its child <a class="el" href="class_picto_1_1_task.html" title="A Task contains the top level StateMachine that defines the logic for researching an experimental que...">Picto::Task</a> object to <a class="el" href="class_picto_1_1_state_machine.html" title="A container for a State Machine defined by StateMachineElement objects connected by Transitions...">Picto::StateMachine</a>. <a class="el" href="class_picto_1_1_state_machine.html" title="A container for a State Machine defined by StateMachineElement objects connected by Transitions...">Picto::StateMachine</a> will give you a good sense of how control flow traverses through the Picto design. It will lead you to look at <a class="el" href="class_picto_1_1_state.html" title="The StateMachineElement that handles rendering of graphical, audio and signal elements and responding...">Picto::State</a>, <a class="el" href="class_picto_1_1_switch_element.html" title="A state machine element that switches the control flow path based on the results of a script...">Picto::SwitchElement</a> and other <a class="el" href="class_picto_1_1_state_machine_element.html" title="A StateMachineElement is any element that can be part of the control flow in a StateMachine. ">Picto::StateMachineElement</a> objects. Once you are somewhat familiar with control flow, you can start working your way through the class inheritance tree that provides the functionality to things like <a class="el" href="class_picto_1_1_state.html" title="The StateMachineElement that handles rendering of graphical, audio and signal elements and responding...">Picto::State</a>, <a class="el" href="struct_picto_1_1_visual_element.html" title="A base class for all elements that represent graphics to be drawn onto the the display&#39;s Scene...">Picto::VisualElement</a>, etc.</p>
<p>Once you are familiar with the Design stucture, you can get back to the individual Viewers.</p><ul>
<li>The <a class="el" href="class_state_edit_viewer.html" title="The StateEditViewer is a container for the Designer widget which is a development environment for cre...">StateEditViewer</a> is really just a container for the Picto::Designer, so you'll want to look at that. When you are moving through all of the various widgets that the <a class="el" href="class_designer.html" title="A Graphical State Machine Integrated Development Environment for creating Picto Experiments and Analy...">Designer</a> uses, keep in mind that the Picto::EditorState is very important. It is the glue that holds the <a class="el" href="class_designer.html" title="A Graphical State Machine Integrated Development Environment for creating Picto Experiments and Analy...">Designer</a> together, allowing different widgets to communicate through the use of Qt Signals and Slots.</li>
<li>The <a class="el" href="class_test_viewer.html" title="This allows designers to run the Experiment/Analysis that they are creating in a test environment for...">TestViewer</a> contains some complexity associated with selecting, setting up and running Analyses that can be a little distracting. When starting out, focus on the <a class="el" href="class_test_playback_controller.html" title="The TestPlaybackController handles the play(), pause(), stop() interface to an Experiment. ">TestPlaybackController</a>. This is where the code that actually runs the Experiment Tasks lives.</li>
<li>Before looking through the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a>, look at the <a class="el" href="class_picto_1_1_slave_experiment_driver.html" title="Connects a StateUpdater to an Experiment to drive an Experiment in slave mode. ">Picto::SlaveExperimentDriver</a>, <a class="el" href="class_picto_1_1_state_updater.html" title="An interface class for objects that update the Picto State from some external source. ">Picto::StateUpdater</a> system and the RemoteStateUpdater implementation of StateUpdater. These define the system that allows a master Experiment to control a slave, and the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a> uses them to run the SlaveExperiment.</li>
<li>The <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> should be much clearer if you've gone through the <a class="el" href="class_picto_1_1_slave_experiment_driver.html" title="Connects a StateUpdater to an Experiment to drive an Experiment in slave mode. ">Picto::SlaveExperimentDriver</a>, <a class="el" href="class_picto_1_1_state_updater.html" title="An interface class for objects that update the Picto State from some external source. ">Picto::StateUpdater</a> system from the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a> guidelines. The <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> uses the same setup, except that the <a class="el" href="class_picto_1_1_state_updater.html" title="An interface class for objects that update the Picto State from some external source. ">Picto::StateUpdater</a> in this case is a PlaybackStateUpdater controlled by a <a class="el" href="class_playback_controller.html" title="The top level object that controls Session playback using the PlaybackStateUpdater and SlaveExperimen...">PlaybackController</a> that runs in its own thread. Again, there is some complexity associated with setting up, selecting and activating Analyses in the <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> code that can be distracting. If you can start with an understanding of how the <a class="el" href="class_playback_controller.html" title="The top level object that controls Session playback using the PlaybackStateUpdater and SlaveExperimen...">PlaybackController</a> manages playback, it should make the <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> functionality a little bit clearer.</li>
</ul>
<h1><a class="anchor" id="first_look_Server"></a>
Server</h1>
<p>Parts of the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> dealing with the actual sending an receiving of data over the network socket can get somewhat complicated. It is best to start with the high level function of the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> and save its low level infrastructure for later. Start out with the assumption that the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> recieves commands from the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a>, Proxy and Workstation, somehow processes them and sends them into the appropriate ProtocolCommandHandler. The classes that extend ProtocolCommandHandler can be found in server\protocol. Focus on the main interfaces for the workstation: StartSessionCommandHandler and <a class="el" href="struct_task_command_handler.html" title="Handles TASK commands. ">TaskCommandHandler</a>, and the main interfaces for the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> and Proxy: <a class="el" href="struct_put_data_command_handler.html" title="Handles PUTDATA commands sent by Director and Proxy. ">PutDataCommandHandler</a> and <a class="el" href="struct_component_update_command_handler.html" title="Handles COMPONENTUPDATE commands, which are sent by ComponentInterface objects (Director and Proxy)...">ComponentUpdateCommandHandler</a>. These handlers will lead you into exploring the <a class="el" href="class_connection_manager.html" title="Keeps track of all active Components (Director/Proxy) as well as all active and recently timed out Se...">ConnectionManager</a> class and the particularly important <a class="el" href="class_session_info.html" title="Manages data for a single Session. Stores data needed for Session monitoring in RAM and Session data ...">SessionInfo</a> class, which is really the heart of the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> application.</p>
<p>Once you have gone through these pieces, you can look back at the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> infrastructure: <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a>, <a class="el" href="class_server_thread.html" title="A thread used to handle TCP connections. ">ServerThread</a>, <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">Picto::ProtocolCommand</a>, etc. The main method for the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> application, in server\main.cpp happens to be particularly complicated since the application can be run from both the command line and as a system service. It is not all that important that you understand the details of what is happening in server\main.cpp unless you need to edit it. Don't spend too much time on it at this stage.</p>
<h1><a class="anchor" id="first_look_Director"></a>
Director</h1>
<p>The <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> class inherits <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a>, and the application is essentially started when <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a>\main.cpp calls Picto::ComponentInterface::activate(). It would be a good idea to start by looking through Picto::ComponentInterface. Next, look at <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> and try to get a good idea of how it is implementing the <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a>. At this point, although it is somewhat counter intuitive, it would be a good idea to look at <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">Picto::CommandChannel::processResponses()</a>. This turns out to be a vitally important function for both the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> and Proxy, more details are available in that function's documentation. After looking at the processResponses() function, check out the classes in director\protocol that extend the various ProtocolResponseHandler classes along with Picto::StatusManager and <a class="el" href="class_director_status_manager.html" title="Handles overall status operations for a Director object. ">DirectorStatusManager</a>. In particular, <a class="el" href="struct_director_start_response_handler.html" title="Implements StartResponseHandler to run a Task whose name is included in a message over the network...">DirectorStartResponseHandler</a> does the work of actually running the Experiment Task.</p>
<h1><a class="anchor" id="first_look_Proxy"></a>
Proxy</h1>
<p>Like the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a>, the Proxy class inherits <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a>, and the application is essentially started when the <a class="el" href="class_proxy_main_window.html" title="The main window of the proxy server. ">ProxyMainWindow</a>'s Picto::ComponentInterface::activate() function is called. In the Proxy's case, the function is called due to a one shot timer in the <a class="el" href="class_proxy_main_window.html" title="The main window of the proxy server. ">ProxyMainWindow</a> constructor. Assuming that you have gone through the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> section, you have already looked at Picto::ComponentInterface and <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">Picto::CommandChannel::processResponses()</a>. Next you should look at the <a class="el" href="struct_proxy_new_session_response_handler.html" title="Extends NewSessionResponseHandler to gather Neural data and send it to the Picto Server until the Ses...">ProxyNewSessionResponseHandler</a>. Its ProxyNewSessionResponseHander::processResponse() function is actually responsible for capturing and sending Proxy data to the server. Next, look at <a class="el" href="class_neural_data_acq_interface.html" title="Interface used for all proxy server plugins. ">NeuralDataAcqInterface</a>. This class is implemented in each of the Proxy plugins, for Plexon, TDT and the Virtual Device. In each case, the class that implements <a class="el" href="class_neural_data_acq_interface.html" title="Interface used for all proxy server plugins. ">NeuralDataAcqInterface</a> takes care of interfacing with the actual Neural Data Acquisition device. Now you should have a pretty broad sense of how the Proxy works, and you can look back at <a class="el" href="class_proxy_main_window.html" title="The main window of the proxy server. ">ProxyMainWindow</a> for some of the GUI details.</p>
<h1><a class="anchor" id="first_look_Embedded"></a>
Embedded Front Panel</h1>
<p>The EmbeddedFrontPanel application is fairly simple. The main method of embedded\frontpanel\main.cpp creates a <a class="el" href="class_menu.html" title="The top level object for the front panel that creates all operable DisplayModes and connects them to ...">Menu</a> object and a <a class="el" href="class_phidgets.html" title="Provides an interface to the Phidgets devices used by the FrontPanel Application. ...">Phidgets</a> object. <a class="el" href="class_phidgets.html" title="Provides an interface to the Phidgets devices used by the FrontPanel Application. ...">Phidgets</a> handles the interface to the Pictobox front panel and knob hardware, <a class="el" href="class_menu.html" title="The top level object for the front panel that creates all operable DisplayModes and connects them to ...">Menu</a> handles the logic controlling what is displayed on the hardware. Start by looking at <a class="el" href="class_menu.html" title="The top level object for the front panel that creates all operable DisplayModes and connects them to ...">Menu</a>. In particular, look at Menu::loadMenus() where the various <a class="el" href="class_display_mode.html" title="A display mode that defines the results of user interactions and controls the front panel LCD when it...">DisplayMode</a> options are setup, and <a class="el" href="class_menu.html#a3a8a0e8b13f44978f239e280d78b38bd" title="Accepts user input from the phidgets interface and routes it to the active DisplayMode or appropriate...">Menu::userInputSlot()</a> where input from the <a class="el" href="class_phidgets.html" title="Provides an interface to the Phidgets devices used by the FrontPanel Application. ...">Phidgets</a> dial cause the current <a class="el" href="class_display_mode.html" title="A display mode that defines the results of user interactions and controls the front panel LCD when it...">DisplayMode</a> to switch. Next look at the <a class="el" href="class_display_mode.html" title="A display mode that defines the results of user interactions and controls the front panel LCD when it...">DisplayMode</a> class and go over some of its child classes. Check out <a class="el" href="class_director_interface.html" title="An interface that encapsulates socket communicate to the director from the Front Panel Application...">DirectorInterface</a> to see how the EmbeddedFrontPanel actually interfaces with the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a>. Don't spend too much time worrying about the details of the <a class="el" href="class_phidgets.html" title="Provides an interface to the Phidgets devices used by the FrontPanel Application. ...">Phidgets</a> class. It looks complicated, but is really just a translator from the world of <a class="el" href="class_phidgets.html" title="Provides an interface to the Phidgets devices used by the FrontPanel Application. ...">Phidgets</a> to the world of the EmbeddedFrontPanel. Unless <a class="el" href="class_phidgets.html" title="Provides an interface to the Phidgets devices used by the FrontPanel Application. ...">Phidgets</a> adds some new feature or something, you probably won't need to do much to it. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
