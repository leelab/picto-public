<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Picto: Picto::InputPort Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="pictodoc.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Picto
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Picto</b></li><li class="navelem"><a class="el" href="class_picto_1_1_input_port.html">InputPort</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_picto_1_1_input_port-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Picto::InputPort Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Used to collect data from a single port that may handle multiple signals.  
 <a href="class_picto_1_1_input_port.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_input_port_8h_source.html">InputPort.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Picto::InputPort:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_picto_1_1_input_port.png" usemap="#Picto::InputPort_map" alt=""/>
  <map id="Picto::InputPort_map" name="Picto::InputPort_map">
<area href="class_picto_1_1_legacy_system_x_p_analog_input_port.html" title="An InputPort object for collecting analog input data when running Picto on a LegacySystemXP (ie..." alt="Picto::LegacySystemXPAnalogInputPort" shape="rect" coords="0,56,235,80"/>
<area href="class_picto_1_1_mouse_input_port.html" title="A signal channel for use with the mouse. " alt="Picto::MouseInputPort" shape="rect" coords="245,56,480,80"/>
<area href="class_picto_1_1_picto_box_x_p_analog_input_port.html" title="An InputPort object for collecting analog input data. Runs on a PictoBox. " alt="Picto::PictoBoxXPAnalogInputPort" shape="rect" coords="490,56,725,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae49fa1de9c84fe7e836b7e4377395c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#ae49fa1de9c84fe7e836b7e4377395c85">addInputChannel</a> (int channelNum, int msPerSample)</td></tr>
<tr class="memdesc:ae49fa1de9c84fe7e836b7e4377395c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new input channel to this <a class="el" href="class_picto_1_1_input_port.html" title="Used to collect data from a single port that may handle multiple signals. ">InputPort</a> that is to be sampled at the input number of msPerSample.  <a href="#ae49fa1de9c84fe7e836b7e4377395c85">More...</a><br /></td></tr>
<tr class="separator:ae49fa1de9c84fe7e836b7e4377395c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b518f5abf207187207da782e32302b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a38b518f5abf207187207da782e32302b">enable</a> (bool en)</td></tr>
<tr class="separator:a38b518f5abf207187207da782e32302b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0230b63e579442362a33b7aa0a6b3a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#aa0230b63e579442362a33b7aa0a6b3a1">updateDataBuffer</a> (double currTimestamp)</td></tr>
<tr class="memdesc:aa0230b63e579442362a33b7aa0a6b3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the empty <a class="el" href="class_picto_1_1_input_port.html#a885502b8712d339b918ac0c6ba418957" title="Loads channelBuffers_ with data, returns the precise time when the data was actually read...">updateDataBuffer()</a> function to load data from the DAQ into channelBuffers_, then aligns timestamps in case of an imperfect DAQ clock.  <a href="#aa0230b63e579442362a33b7aa0a6b3a1">More...</a><br /></td></tr>
<tr class="separator:aa0230b63e579442362a33b7aa0a6b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c3cd9769baa2edc9591796bc52232f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09c3cd9769baa2edc9591796bc52232f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a09c3cd9769baa2edc9591796bc52232f">hasNewData</a> (int channelNum)</td></tr>
<tr class="memdesc:a09c3cd9769baa2edc9591796bc52232f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is new data available on this <a class="el" href="class_picto_1_1_input_port.html" title="Used to collect data from a single port that may handle multiple signals. ">InputPort</a>. <br /></td></tr>
<tr class="separator:a09c3cd9769baa2edc9591796bc52232f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a8fb8f8ef139a6387898ec5fa0fab7"><td class="memItemLeft" align="right" valign="top">QVector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a02a8fb8f8ef139a6387898ec5fa0fab7">getData</a> (int channelNum)</td></tr>
<tr class="memdesc:a02a8fb8f8ef139a6387898ec5fa0fab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of data samples for the input channel number.  <a href="#a02a8fb8f8ef139a6387898ec5fa0fab7">More...</a><br /></td></tr>
<tr class="separator:a02a8fb8f8ef139a6387898ec5fa0fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f084ee011ca2a5298f6a088f56ed6b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f084ee011ca2a5298f6a088f56ed6b7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a4f084ee011ca2a5298f6a088f56ed6b7">getFrameToSampleOffset</a> (int channelNum)</td></tr>
<tr class="memdesc:a4f084ee011ca2a5298f6a088f56ed6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the offset from the time that the previous frame occured to the time that the first sample on the input channel was read. <br /></td></tr>
<tr class="separator:a4f084ee011ca2a5298f6a088f56ed6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59767d320f491e862c400052c6dc6657"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59767d320f491e862c400052c6dc6657"></a>
virtual QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a59767d320f491e862c400052c6dc6657">type</a> ()</td></tr>
<tr class="memdesc:a59767d320f491e862c400052c6dc6657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with the name of this type of <a class="el" href="class_picto_1_1_input_port.html" title="Used to collect data from a single port that may handle multiple signals. ">InputPort</a>. <br /></td></tr>
<tr class="separator:a59767d320f491e862c400052c6dc6657"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aefd4ff8fcdb966e2d39c47d244ed6925"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefd4ff8fcdb966e2d39c47d244ed6925"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#aefd4ff8fcdb966e2d39c47d244ed6925">startSampling</a> ()=0</td></tr>
<tr class="memdesc:aefd4ff8fcdb966e2d39c47d244ed6925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts sampling of the DAQ hardware. Returns false if sampling can't be started. <br /></td></tr>
<tr class="separator:aefd4ff8fcdb966e2d39c47d244ed6925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0980bd23dd8c524d3e30394539b5850f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0980bd23dd8c524d3e30394539b5850f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a0980bd23dd8c524d3e30394539b5850f">stopSampling</a> ()=0</td></tr>
<tr class="memdesc:a0980bd23dd8c524d3e30394539b5850f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops sampling of the DAQ hardware. Returns false if sampling can't be stopped. <br /></td></tr>
<tr class="separator:a0980bd23dd8c524d3e30394539b5850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885502b8712d339b918ac0c6ba418957"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a885502b8712d339b918ac0c6ba418957"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a885502b8712d339b918ac0c6ba418957">updateDataBuffer</a> ()=0</td></tr>
<tr class="memdesc:a885502b8712d339b918ac0c6ba418957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads channelBuffers_ with data, returns the precise time when the data was actually read. <br /></td></tr>
<tr class="separator:a885502b8712d339b918ac0c6ba418957"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab903e1969d02f8ec9f7644b302b224c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab903e1969d02f8ec9f7644b302b224c1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#ab903e1969d02f8ec9f7644b302b224c1">deviceSampRate_</a></td></tr>
<tr class="memdesc:ab903e1969d02f8ec9f7644b302b224c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the rate at which the Daq device will be sampled. <br /></td></tr>
<tr class="separator:ab903e1969d02f8ec9f7644b302b224c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fd054102d952d0c77724715be1b686"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7fd054102d952d0c77724715be1b686"></a>
QVector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#af7fd054102d952d0c77724715be1b686">channelNums_</a></td></tr>
<tr class="memdesc:af7fd054102d952d0c77724715be1b686"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing the channels to be sampled by the Daq device. <br /></td></tr>
<tr class="separator:af7fd054102d952d0c77724715be1b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aff384b2a6d499f824a1cbb9f7746a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09aff384b2a6d499f824a1cbb9f7746a"></a>
QHash&lt; int, QVector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a09aff384b2a6d499f824a1cbb9f7746a">channelBuffers_</a></td></tr>
<tr class="memdesc:a09aff384b2a6d499f824a1cbb9f7746a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash of data buffers indexed by channel number to be filled by the child class. <br /></td></tr>
<tr class="separator:a09aff384b2a6d499f824a1cbb9f7746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:adca1b75ce2e4918d6325451b23cf2541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#adca1b75ce2e4918d6325451b23cf2541">start</a> ()</td></tr>
<tr class="memdesc:adca1b75ce2e4918d6325451b23cf2541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the DAQ collecting data.  <a href="#adca1b75ce2e4918d6325451b23cf2541">More...</a><br /></td></tr>
<tr class="separator:adca1b75ce2e4918d6325451b23cf2541"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9e056370043a71e4080f39bbc3f150ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e056370043a71e4080f39bbc3f150ec"></a>
QHash&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a9e056370043a71e4080f39bbc3f150ec">sampResMap_</a></td></tr>
<tr class="memdesc:a9e056370043a71e4080f39bbc3f150ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps channel num to samplerate. <br /></td></tr>
<tr class="separator:a9e056370043a71e4080f39bbc3f150ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018e100737a3ff84db00e568456b6f42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018e100737a3ff84db00e568456b6f42"></a>
QHash&lt; int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a018e100737a3ff84db00e568456b6f42">latestFrameOffsetTimes_</a></td></tr>
<tr class="memdesc:a018e100737a3ff84db00e568456b6f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset times between start of frame and first input sample, indexed by channel. <br /></td></tr>
<tr class="separator:a018e100737a3ff84db00e568456b6f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41380c1b3dda1474f010d8295bfe09b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41380c1b3dda1474f010d8295bfe09b"></a>
QHash&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#af41380c1b3dda1474f010d8295bfe09b">sampsPerReadMap_</a></td></tr>
<tr class="memdesc:af41380c1b3dda1474f010d8295bfe09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of samples to be returned per read, indexed by channel. <br /></td></tr>
<tr class="separator:af41380c1b3dda1474f010d8295bfe09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ca8c443c7c2ae12b97bff252cc4c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d8ca8c443c7c2ae12b97bff252cc4c9"></a>
QHash&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a7d8ca8c443c7c2ae12b97bff252cc4c9">channelPhaseMap_</a></td></tr>
<tr class="memdesc:a7d8ca8c443c7c2ae12b97bff252cc4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of samples retained from previous reads for future return (the measurement offset), indexed by channel. <br /></td></tr>
<tr class="separator:a7d8ca8c443c7c2ae12b97bff252cc4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62015fe27445184f80ce1a8ba2544ad9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62015fe27445184f80ce1a8ba2544ad9"></a>
QHash&lt; int, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a62015fe27445184f80ce1a8ba2544ad9">polledDataMap_</a></td></tr>
<tr class="memdesc:a62015fe27445184f80ce1a8ba2544ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks whether the channel data has been polled, indexed by channel. <br /></td></tr>
<tr class="separator:a62015fe27445184f80ce1a8ba2544ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4102969f9644b2c609782970e32990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd4102969f9644b2c609782970e32990"></a>
QHash&lt; int, QVector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#afd4102969f9644b2c609782970e32990">channelLeftOvers</a></td></tr>
<tr class="memdesc:afd4102969f9644b2c609782970e32990"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash of data buffers indexed by channel number with data that will be used on the next <a class="el" href="class_picto_1_1_input_port.html#aa0230b63e579442362a33b7aa0a6b3a1" title="Calls the empty updateDataBuffer() function to load data from the DAQ into channelBuffers_, then aligns timestamps in case of an imperfect DAQ clock. ">updateDataBuffer(double)</a> call. <br /></td></tr>
<tr class="separator:afd4102969f9644b2c609782970e32990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc85c94cb5927fc32187a41c99443a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dc85c94cb5927fc32187a41c99443a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a0dc85c94cb5927fc32187a41c99443a5">taskRunning_</a></td></tr>
<tr class="memdesc:a0dc85c94cb5927fc32187a41c99443a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the task is currently running. <br /></td></tr>
<tr class="separator:a0dc85c94cb5927fc32187a41c99443a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa00118360b4fb10697a86c828d555f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa00118360b4fb10697a86c828d555f4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#aaa00118360b4fb10697a86c828d555f4">sampsCollected_</a></td></tr>
<tr class="memdesc:aaa00118360b4fb10697a86c828d555f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of samples passed added to the DataBuffer. <br /></td></tr>
<tr class="separator:aaa00118360b4fb10697a86c828d555f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4ce9042fc6d730fd5ff7d98b8e89c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d4ce9042fc6d730fd5ff7d98b8e89c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a6d4ce9042fc6d730fd5ff7d98b8e89c5">needsUpdate_</a></td></tr>
<tr class="memdesc:a6d4ce9042fc6d730fd5ff7d98b8e89c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether all channels have been looked at since last update. <br /></td></tr>
<tr class="separator:a6d4ce9042fc6d730fd5ff7d98b8e89c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2781f98f87353df574dce2406b6333"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b2781f98f87353df574dce2406b6333"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#a4b2781f98f87353df574dce2406b6333">lastSyncTimestamp_</a></td></tr>
<tr class="memdesc:a4b2781f98f87353df574dce2406b6333"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last time for which data should be returned for the current frame. <br /></td></tr>
<tr class="separator:a4b2781f98f87353df574dce2406b6333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbf414c63792c971ed3e9fb9f730902"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfbf414c63792c971ed3e9fb9f730902"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_input_port.html#adfbf414c63792c971ed3e9fb9f730902">enabled_</a></td></tr>
<tr class="memdesc:adfbf414c63792c971ed3e9fb9f730902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the port is currently sampling. Flipping this will clear the buffer. <br /></td></tr>
<tr class="separator:adfbf414c63792c971ed3e9fb9f730902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Used to collect data from a single port that may handle multiple signals. </p>
<p>Since in many cases different input lines on a single DAQ device port cannot be configured to be sampled at different sample rates, this class handles finding a sample rate that is high enough that it can be used to provide the desired sample rate for all desired input channels, and then down sampling the resultant data to provide data at those desired sample rates. Another common issue with DAQ devices is that their clocks are fairly innaccurate (apparently this is the trade off for being able to set whatever sample rate you want). These inaccurate sample clocks can create significant timing errors over the even a few seconds. This class handles synchronization of the DAQ sample clock and the Picto clock. It does this by comparing the calculated time of the incoming data assuming a perfect DAQ clock and comparing it to the time which the data was read according to the Picto clock. If the calculated clock dictates that the last data sample was read significantly before the time read on the Picto clock, data points are duplicated. If on the other hand, the calculated clock dictates that the last data point was read significantly after the time reported by the Picto clock, data points at the end are deleted. To keep from deleting significant information, we always sample the DAQ at 4 times the maximum necessary rate, so that we never need to throw out more than a quarter of a single sample period. This means that data reported by this class will always have been read within a quarter sample period of when it says it was such that we will be working within the set margin of error.</p>
<p>Child classes should handle the actual setup of the underlying device and implement the class's virtual functions. </p><dl class="section author"><dt>Author</dt><dd>Trevor Stavropoulos, Joey Schnurr, Mark Hammond, Matt Gay </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2009-2015 </dd></dl>

<p>Definition at line <a class="el" href="_input_port_8h_source.html#l00035">35</a> of file <a class="el" href="_input_port_8h_source.html">InputPort.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae49fa1de9c84fe7e836b7e4377395c85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InputPort::addInputChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msPerSample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new input channel to this <a class="el" href="class_picto_1_1_input_port.html" title="Used to collect data from a single port that may handle multiple signals. ">InputPort</a> that is to be sampled at the input number of msPerSample. </p>
<p>Since the synchronization algorithm used by this <a class="el" href="class_picto_1_1_input_port.html" title="Used to collect data from a single port that may handle multiple signals. ">InputPort</a> requires that we sample at 4 times the fastest sample rate, we take the Greatest Common Divisor of all channels' sample periods, divide it by 4 and sample at that sample period. </p>

<p>Definition at line <a class="el" href="_input_port_8cpp_source.html#l00038">38</a> of file <a class="el" href="_input_port_8cpp_source.html">InputPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38b518f5abf207187207da782e32302b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InputPort::enable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>en</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The port starts sampling data as soon as the first <a class="el" href="class_picto_1_1_input_port.html#a885502b8712d339b918ac0c6ba418957" title="Loads channelBuffers_ with data, returns the precise time when the data was actually read...">updateDataBuffer()</a> is called if the port is enabled. Disabling the port means that the port will start sampling from scratch the next time it is reenabled and <a class="el" href="class_picto_1_1_input_port.html#a885502b8712d339b918ac0c6ba418957" title="Loads channelBuffers_ with data, returns the precise time when the data was actually read...">updateDataBuffer()</a> is called. </p>

<p>Definition at line <a class="el" href="_input_port_8cpp_source.html#l00100">100</a> of file <a class="el" href="_input_port_8cpp_source.html">InputPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02a8fb8f8ef139a6387898ec5fa0fab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt; double &gt; InputPort::getData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of data samples for the input channel number. </p>
<dl class="section note"><dt>Note</dt><dd>A side effect of this function is that it clears out the data buffer for the input channelNum. </dd></dl>

<p>Definition at line <a class="el" href="_input_port_8cpp_source.html#l00245">245</a> of file <a class="el" href="_input_port_8cpp_source.html">InputPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adca1b75ce2e4918d6325451b23cf2541"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool InputPort::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts the DAQ collecting data. </p>
<p>This should be called as close to the point at which the data will actually be collected as possible. Otherwise, data will pile up in the buffer. Also note that calling this clears out any existing data in the channel.</p>
<p>This function is called by <a class="el" href="class_picto_1_1_input_port.html#a885502b8712d339b918ac0c6ba418957" title="Loads channelBuffers_ with data, returns the precise time when the data was actually read...">updateDataBuffer()</a> </p>

<p>Definition at line <a class="el" href="_input_port_8cpp_source.html#l00079">79</a> of file <a class="el" href="_input_port_8cpp_source.html">InputPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0230b63e579442362a33b7aa0a6b3a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InputPort::updateDataBuffer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currTimestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the empty <a class="el" href="class_picto_1_1_input_port.html#a885502b8712d339b918ac0c6ba418957" title="Loads channelBuffers_ with data, returns the precise time when the data was actually read...">updateDataBuffer()</a> function to load data from the DAQ into channelBuffers_, then aligns timestamps in case of an imperfect DAQ clock. </p>
<p>When this function loads data, it reads the time at which the data was actually read and calculates the time that the last data point came in assuming that each sample was read at exactly the time dictaded by a perfect clock for the set sample period. If the calculated time is significantly lower than the actual time, a data point is duplicated to make up for it. If the calculated time is significantly higher than the actual time, a data point is deleted to make up for it. This function takes care of all of these issues.</p>
<p>The input currTimestamp is the last time for which data should be returned for the current frame. Since there may have been some lag since the latest frame was displayed until this function was called, there may be some data points here that were read after the frame was over. When we read this data though, we only want data that came in up to the time that the frame was presented. This allows us to store data that came in too late for next frame and prepare only the data that occured during the previous frame. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="class_picto_1_1_input_port.html#a885502b8712d339b918ac0c6ba418957" title="Loads channelBuffers_ with data, returns the precise time when the data was actually read...">updateDataBuffer()</a> doesn't do anything unless all input channel data has been read since the last call to this function. </dd></dl>

<p>Definition at line <a class="el" href="_input_port_8cpp_source.html#l00134">134</a> of file <a class="el" href="_input_port_8cpp_source.html">InputPort.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/common/engine/<a class="el" href="_input_port_8h_source.html">InputPort.h</a></li>
<li>source/common/engine/<a class="el" href="_input_port_8cpp_source.html">InputPort.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
