<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Picto: Future Directions in Software</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="pictodoc.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Picto
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Picto Developer&#39;s Guide</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Future Directions in Software </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The following is a list of features that we would like to add to the Picto application suite. Some of these features are purely for the purpose of expanding Picto capability. Others are really refactorizations for the purpose of removing limitations in the the current system. Obviously this is not an exhaustive list, and the more features that we add, the more feature ideas we will undoubtedly come up with. In cases where we have given some thought to how a feature should be implemented, we have included it in this list. In other cases, implementation is entirely up to you the developer.</p>
<p><b>Picto Experiments should be run as part of the Qt event loop</b><br />
 Picto Tasks are not currently run as part of the Qt Event loop. Currently, <a class="el" href="class_picto_1_1_experiment.html#a6cfd77559307223a8121a6a016b489c2" title="Runs the Task with the input taskName starting with the initial transition in its top level StateMach...">Picto::Experiment::runTask()</a> starts a task and doesn't return until the Task is complete. In order for Tasks to run as part of the Qt event loop, we would need to set a timer to trigger a top level runFrameLogic() function every frame from the event loop. This function would locate the current Task control state, then cause all scripts to run and all transitions to be traversed until control reached the code that renders the next frame. We would then wait for first phosphor presentation in that frame, run any code that needs to happen at the time of the first phosphor, and return to the event loop. Any OS events, network events, etc could then happen as a natural part of the Qt event loop in the time between first phosphor presentations and processing for the next render. This would allow a whole lot of things in Picto to run a whole lot more smoothly. In particular, right now in Picto any time we send a message over the network to the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a>, rather than using the standard method of connecting to network events, we need to find a place in local logic to poll the network socket and wait for a response. Inevitably, this ends up wasting a lot of time and seriously complicating the code. The reason that Picto wasn't built to run as part of the Qt event loop in the first place is due to computers having being historically slower that they are now and the fear that allowing the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> application to handle OS events might cause skipped frames. At this point it is our belief, considering the simplicity of our Experiments and the speed of new processors, that allowing the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> application to handle OS events will not have any effect on frame rate. For more details on this issue, see <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">Picto::CommandChannel::processResponses()</a>. Also, note that the implementation of this feature is a very significant task that involves touching a lot of pieces of Picto code. It should definitely not be taken on as one of a new developer's first tasks.</p>
<p><b>Add LFP and Spike data to a <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> audio channel</b><br />
 Currently, while LFP and Spike data are available from Analysis code, they are not presented in any way in the <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> GUI. There are a number of possibilities for presenting this data. In the case of the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a>, the data is presented in a separate tab on a plot; however, experience shows that one of the most convenient ways to present the data is over an audio channel so that researchers can hear changes to neural data while simultaneously watching what is going on in the behavioral task. In the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a>, for various reasons, there is at least a half second delay between the current behavioral time and LFP data coming in from the neural system which makes a live audio signal less feasible. In the <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a>, however, we should be able to playback neural data in an audio channel while the behavioral task is being played back. The idea would be to allow the operator to select a channel/unit and playback all spikes on that channel/unit as simple ticks. LFP data for that channel would be directly pumped into the audio stream as a background hum behind the spike ticks. In terms of implementation, the spike/lfp playback system is already in place but there is some plumbing that will need to be done in bringing the <a class="el" href="class_picto_1_1_session_state.html#a5ab201c9c6bbe8e09774987465bcc2df" title="Emitted when playback moves the current time passed a new lfp value. ">Picto::SessionState::lfpChanged()</a> and <a class="el" href="class_picto_1_1_session_state.html#a41d2edbdbc1239351e37402c8c5d41d0" title="Emitted whenever a spike time is passed as part of playback. ">Picto::SessionState::spikeEvent()</a> signals up to the StateUpdater interface. Once there, we should be able to connect to those signals and send their data out to an audio channel. More recent versions of Qt have exposed a lot of new functionality for dealing with audio and multimedia in general. In searching for a method of outputing raw audio data, that would be a good place to start.</p>
<p><b>Add AnalysisVisualElements to the Analysis system</b><br />
 Currently, there is one means of output for Analyses which is the AnalysisFileOutput. The AnalysisFileOutput comes with a AnalysisFileOutputWidget that displays output file data in a side bar of the <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> and <a class="el" href="class_test_viewer.html" title="This allows designers to run the Experiment/Analysis that they are creating in a test environment for...">TestViewer</a> during playback. When we record Session playback into a video file though, we only record what happes in the main window of the <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> and it would be nice to be able to add new information to that display such that it overlays what was happening during the Session. The simplest way to do this would be to add AnalysisVisualElements that would be added to Analyses and displayed with exactly the same rules as their Experimental VisualElement counter parts when their Analysis was activated. There could be any number of AnalysisVisualElement classes for displaying text, xyPlots, rasterPlots, progressBars, etc. This way, if a researcher wanted to show how a specific piece of data changes during the course of a trial, they could simply add an appropriate AnalysisVisualElement and update it accordingly while the trial progressed. Imagine, for example, if we implemented a raster AnalysisVisualElement. During the course of each trail, in each frame script we could use an AnalysisFunction to send the latest spikes to the raster plot. The raster could be placed at the bottom of the display such that our video file would show not only what the test subject was doing during the trial, but also how a correlated neuron's spike density changed during that trial.</p>
<p><b>Add Audio to video files</b><br />
 Currently, video files recorded from the <a class="el" href="class_replay_viewer.html" title="Defines the UI for the ReplayViewer. ">ReplayViewer</a> do not record sound. It turns out that adding audio to the video file is harder than you might expect. In fact, as of this writing, even with all of its new multimedia functionality Qt does not provide any convenient way of programmatically generating a video file (it's support is limited to capturing and saving images from a webcam - see my stack overflow question on the topic: <a href="http://stackoverflow.com/questions/14566470/create-video-programmatically-with-qt-5-0">http://stackoverflow.com/questions/14566470/create-video-programmatically-with-qt-5-0</a>). We used qtffmpegwrapper for this purpose. qtffmpegwrapper is a qt interface to the ffmpeg system and does the job in a not-to-complicated way, but does not support audio. The qtffmpegwrapper along with all necessary ffmpeg binaries is stored in Picto\3rdparty\qtffmpegwrapper. It will undoubtedly need to be updated at some point when Windows changes their API or something and can be found online at <a href="https://code.google.com/p/qtffmpegwrapper/">https://code.google.com/p/qtffmpegwrapper/</a>. To add audio support to saved Picto videos though, you'll need to either change the qtffmpegwrapper code to add an audio interface (unless someone else has already done it by the time you read this), use Qt directly if it has added video writing support by now, or find some better method.</p>
<p><b>Integrate Picto analysis with Matlab</b><br />
 This feature is more of a long term goal and we haven't done much research on it as of yet. The idea is to make use of the Matlab API to send Analysis output data directly to Matlab. Depending on how flexible the Matlab API is, we could possibly put Matlab plots and other windows directly into the AnalysisOutputWidgetContainer, use them a pop-ups or simply pipe data into a running Matlab application. The method for doing this is up to you, but the idea would be to implement the interface inside a MatlabAnalysisOutput object (ie. MatlabPlotAnalysisOutput) that could be added to a Picto Analysis design just like any other AnalysisOutput object.</p>
<p><b>Put all Picto systems onto one <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a></b><br />
 The orignal plan for Picto was to have one central server that handles all running Picto Sessions simultaneously. In fact, the current Picto <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> is capable of handling a small number of simultaneous Sessions on different Directors so long as the Sessions are simple without large quantities of data like LFP. The problem with handling multiple Sessions at once is that there is so much overhead in writing data to SQL. We found that due to this overhead, a single Picto Session with neural data can take up a very significant percentage of <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> processing time, and for this reason the decision was made to add system numbers so that multiple Servers could run on the same network and run a separate <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> for every Director/Proxy system. The fact is though, that the data saved on the Picto <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> is almost entirely serial, and there really is no need to perform any SQL read queries on the Session data during the course of a Session. For this reason, it would make sense to reimplement the <a class="el" href="class_session_info.html" title="Manages data for a single Session. Stores data needed for Session monitoring in RAM and Session data ...">SessionInfo</a> code (and <a class="el" href="class_stored_session_data.html" title="Handles long term storage of session data in an SQL file. ">StoredSessionData</a>) such that it saves data in a simple file as a simple byte array. It is certainly good for finalized Session files to be saved in SQL for the purpose of easy upgrading and debugging, so a separate tool could be created to convert the simple serial file to an SQL file. This tool could be run when the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> wasn't busy handling Sessions overnight to convert the previous days saved data to SQL Session files. In the spacial case where a Workstation wants to analyze Session data right away, we could add the tool to the Workstation so that it could perform the conversion on its own. We have not run tests of saving serial file data, but it should remove file access as the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> bottleneck since generally file access is considered much quicker than interfacing over a network.</p>
<p><b>Add line numbers to Picto Scripts</b><br />
 We will need to extend the <a class="el" href="class_script_text_edit.html" title="A Text Editor widget for Picto scripts. ">ScriptTextEdit</a> class to do this.</p>
<p><b>Implement standardized region/manifold/channel data storage</b><br />
 When recording with neural data, it is important to save information about the neural recording setup used with a particular session. Currently, researchers can do this by adding the relevant data to the RunNotes in the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a>; however since this needs to be done by everyone for every Session, it would be good to set up a standard way to do this. It would also be very useful if the method allowed the data to be searchable in the future so that, for example, we could select out all sessions that dealt with a particular brain region. There are many ways to do this. One that comes to mind would be to add some type of additonal configuration to the Picto <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a>. The <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> could be configured with a list of categories for which data could be saved and a list of possible values for each category. The Workstation could then query the saveable categories and category values when it joins/starts a Session. In the <a class="el" href="class_task_run_viewer.html" title="A viewer that displays data about the Task Runs from the current session and allows the operator to e...">TaskRunViewer</a>, it could provide a section with a little '+' button to add a new category and category value, each of which could be filled in using drop down menus. The values entered there could then be sent to the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> along with the RunNotes and saved in a searchable SQL table in the Session file. By doing things in this way, we would make it easy to search over multiple Sessions for particular Region/Manifold/Channel values. We would also leave things general so that the categories could be set up differently for other research applications.</p>
<p><b>Implement getToken(index) function on TokenFactoryGraphic</b><br />
 We have recieved some user feedback indicating that it would be very useful to be able to treat individual tokens in a TokenFactoryGraphic as their own separate objects with their own functions and script properties. This would not add any new functionality to Picto but it would make design more convenient for systems that require configurable numbers of tokens. This should be doable by creating a Token class that inherits QObject and interfaces with the TokenFactoryGraphic whenever getToken(index) is called and adding it to the current QScriptEngine (hopefully the current QScriptEngine is accessible somehow). Remember that whenever we add a new function or script property to anything we need to be very sure of it. As soon as someone uses a that script function/property, we need Picto to be backward compatible with it forever!</p>
<p><b>Allow Neural Data Acquisition systems and the Proxy to stop and start during the course of a Session</b><br />
 Currently, if the Plexon or TDT systems stop recording during the course of a Session, even if they restart the Proxy is unable to gather any further data until a new Session is started with that Proxy. Similarly, if a Proxy is closed accidentally, even if it is opened again it cannot reconnect to its Session and continue gathering data. It would be good if we could support these functions.</p>
<p><b>Add settable waveform sample period to Proxy</b><br />
 Currently, every waveform that is recorded on the TDT or Plexon systems is sent to the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> and saved to the Session file. This wastes space since it really is not necessary to save every single waveform. It would be nice to add an option to the Proxy window to select the waveform sample period.</p>
<p><b>Add "link to syntax error" in <a class="el" href="class_state_edit_viewer.html" title="The StateEditViewer is a container for the Designer widget which is a development environment for cre...">StateEditViewer</a></b><br />
 The <a class="el" href="class_state_edit_viewer.html" title="The StateEditViewer is a container for the Designer widget which is a development environment for cre...">StateEditViewer</a> includes a syntax checker system that reports script and structural errors in a tab of the bottom centeral widget. It would be nice if you could click on these errors and cause the <a class="el" href="class_state_edit_viewer.html" title="The StateEditViewer is a container for the Designer widget which is a development environment for cre...">StateEditViewer</a> context to automatically move to the element with the error. In the case of script syntax errors, it would be nice if the cursor could automatically enter the problematic script at the error line.</p>
<p><b>Allow a <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> to determine if it supports a given Experiment</b><br />
 Some Experiment designs include elements that may not be supported by a <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a>. For example, a <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> running on a Pictobox that is connected to a Neural Data Aquisition system is configured without the "-onesided" tag since it uses its parallel port to send alignment codes to the neural system. This means that that <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a>'s parallel port can't be used as an output for a BinaryDataOutput object. If an Experiment loaded onto that <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> included a BinaryDataOutput object, it would be useful if the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> could send a NOTSUPPORTED command to let the Workstation know that the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> cannot run that Experiment and either the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> needs to be reconfigured or the Design adjusted.</p>
<p><b>Speed up Undo/Redo and Delete operations</b><br />
 For code simplicity's sake, the Undo/Redo and Delete operations all involve reloading a serialized Design from scratch. In the case of a Delete, we do this to make sure that everything is set up in a clean way after the delete is completed. In the case of Undo and Redo, we do this in order to make use of the QTextDocument's built in Undo / Redo functionality. All we have to do is change an underlying QTextDocument containing the Design's serialized XML whenever an important operation happens. To Undo or Redo, we just call Undo or Redo on that QTextDocument then reload the Design from XML. The problem with this approach is that it is very slow. There are two ways to solve this. The first would be to speed up the deserialization process. We might accomplish this by streamligning the AssetFactory system, wherein multiple different AssetFactory objects are created for every object in the StateMachine tree. Also, part of the complexity in the serialization system is due to the fact that Picto orignally included a TextViewer that showed the actual XML code underlying the Experiment and allowed the user to change it. We wanted to make sure that every operation in the <a class="el" href="class_state_edit_viewer.html" title="The StateEditViewer is a container for the Designer widget which is a development environment for cre...">StateEditViewer</a> could be undone in a way that would affect only the exact area of code where the change occured but leave everything else intact. In particular, we were concerned that the tabbing and xml comments shouldn't get changed or moved due to actions in the <a class="el" href="class_state_edit_viewer.html" title="The StateEditViewer is a container for the Designer widget which is a development environment for cre...">StateEditViewer</a>. Now that the TextViewer is no longer used these concerns are less important and if need be the serialization code could be made more efficient at the expense of allowing <a class="el" href="class_state_edit_viewer.html" title="The StateEditViewer is a container for the Designer widget which is a development environment for cre...">StateEditViewer</a> operations to change more significant portions of the XML design file. Still, it is likely that this won't be sufficient to really get the kind of speed that we want. The other option would be to implement the Undo/Redo/Delete in a completely different way, and this would be a big job. For Delete, it would mean very carefully going through the StateMachine tree code and making sure that a Delete won't break anything (currently actually deleting an element only sets a flag saying "don't serialize this element" out, this would mean actually deleting the element when delete is called). For Undo and Redo, we would need to carefully define a command dispatch system that defines "do" and "undo" effects for every possible type of user action. Then representations of the user actions would be added to a stack after being performed and we could move backwords through that stack performing "undo" effects when we Undo and forward performing "do" effects when we Redo.</p>
<p><b>Create a StateMachineTreeView</b><br />
 Currently, we can only look at one level of the StateMachine tree at a time. It would be useful to add an additional widget in the style of the Windows directory tree that would let us look at multiple levels of the tree at the same time.</p>
<p><b>Unauthorized Workstation's need a way to see if the Session is running</b><br />
 When unauthorized Workstations join a Session, their play/pause/stop buttons are greyed out since they are not allowed to control the Session. This means that they can't see the colors of those buttons, and that means that they can't differentiate between things like a Session that is stopped and one that is paused with no visible VisualElements.</p>
<p><b>Rebuild Neural Channel/Unit lists in the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a> whenever a Run is started</b><br />
 The <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a>'s NeuralViewer keeps track of which channels/units have data on them and adds those channels/units to its lists the first time that data is received. These lists are not cleared until the Workstation detaches from the Session though, so a channel that was active in one run but not used in another can stick around in the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a> UI even though it is completely empty. This should be fixed so that the channel/unit lists are cleared and rebuilt each time a new Run starts.</p>
<p><b>Add verification that no two in-scope OutputSignal elements are controlling the same output port at the same time</b><br />
 There is currently no syntax verification for checkihg whether two OutputSignal elements that are in scope at the same time are trying to control the same digital output port. This is a design error and verification code to this effect should be added to the Design tree.</p>
<p><b>Create a Picto Installer</b><br />
 Picto is currently installed by copying over a standard group of binaries and running a "Visual Studio Redistributable" installation. We should create a simple one shot installer for Picto at some point to streamline this process.</p>
<p><b>Refactor the <a class="el" href="class_test_viewer.html" title="This allows designers to run the Experiment/Analysis that they are creating in a test environment for...">TestViewer</a> as a master and slave Experiment running in parallel</b><br />
 Once we have refactored the Experiment run system to be part of the Qt event loop, it should be fairly straightforward to implement the <a class="el" href="class_test_viewer.html" title="This allows designers to run the Experiment/Analysis that they are creating in a test environment for...">TestViewer</a> as a master Experiment running in a Qt Window sending data to a slave Experiment that handles Analysis. This will help us prepare for implementing real time Picto Analysis.</p>
<p><b>Implement real-time Session Analysis</b><br />
 The idea here is to allow the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a> to analyze an Actively running Session. This will take a lot of thought. Some challenges here are that the Analysis needs all data from the beginning of the Run. It can't just look at the latest data as the current system does. Another challenge is in dealing with AnalysisDataSource objects. These may ask for future data which simply has not happened yet. To handle situations like this, we may need to use two separate slave Experiments in the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a>. One would show realtime behavioral data, and another would run in the background and perform Analysis. The Analysis Slave Experiment would need some way to stop running whenever Analysis code requested "future" data that hadn't been generated yet and restart when the data bacame available. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
