<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Picto: Picto::CommandChannel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="pictodoc.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Picto
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Picto</b></li><li class="navelem"><a class="el" href="class_picto_1_1_command_channel.html">CommandChannel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-slots">Private Slots</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_picto_1_1_command_channel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Picto::CommandChannel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A channel for sending/receiving commands/responses over the network.  
 <a href="class_picto_1_1_command_channel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_command_channel_8h_source.html">CommandChannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Picto::CommandChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_picto_1_1_command_channel.png" usemap="#Picto::CommandChannel_map" alt=""/>
  <map id="Picto::CommandChannel_map" name="Picto::CommandChannel_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab7d91aac6340369c17e2bd2be8a465db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#ab7d91aac6340369c17e2bd2be8a465db">ChannelStatus</a> { <a class="el" href="class_picto_1_1_command_channel.html#ab7d91aac6340369c17e2bd2be8a465dbacab8110f599c9fb57e044a328111b2c6">connected</a>, 
<a class="el" href="class_picto_1_1_command_channel.html#ab7d91aac6340369c17e2bd2be8a465dbad0e2834ef8ac8d240b15e4f43b4bdc46">disconnected</a>
 }</td></tr>
<tr class="memdesc:ab7d91aac6340369c17e2bd2be8a465db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current status of this channel.  <a href="class_picto_1_1_command_channel.html#ab7d91aac6340369c17e2bd2be8a465db">More...</a><br /></td></tr>
<tr class="separator:ab7d91aac6340369c17e2bd2be8a465db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr class="memitem:a58547a1e0081ff7e8aac3ec4d5a4d5fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58547a1e0081ff7e8aac3ec4d5a4d5fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a58547a1e0081ff7e8aac3ec4d5a4d5fc">connectToServer</a> ()</td></tr>
<tr class="memdesc:a58547a1e0081ff7e8aac3ec4d5a4d5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't call from time sensitive zone. <br /></td></tr>
<tr class="separator:a58547a1e0081ff7e8aac3ec4d5a4d5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:aed1770263e417f2334d9dc598695af69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed1770263e417f2334d9dc598695af69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#aed1770263e417f2334d9dc598695af69">connectAttemptFailed</a> ()</td></tr>
<tr class="memdesc:aed1770263e417f2334d9dc598695af69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when an attempt to connect to the server fails. <br /></td></tr>
<tr class="separator:aed1770263e417f2334d9dc598695af69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257a279e6a6b8ddfe4a22339e348d865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a257a279e6a6b8ddfe4a22339e348d865"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a257a279e6a6b8ddfe4a22339e348d865">channelDisconnected</a> ()</td></tr>
<tr class="memdesc:a257a279e6a6b8ddfe4a22339e348d865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted whenever the connection to the server is disconnected, whether by intention or not. <br /></td></tr>
<tr class="separator:a257a279e6a6b8ddfe4a22339e348d865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a85b38c5e9e5989ba8c1fec047e3cfbea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a85b38c5e9e5989ba8c1fec047e3cfbea">CommandChannel</a> (QUuid sourceId, QString sourceType, QObject *parent=0)</td></tr>
<tr class="memdesc:a85b38c5e9e5989ba8c1fec047e3cfbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a>.  <a href="#a85b38c5e9e5989ba8c1fec047e3cfbea">More...</a><br /></td></tr>
<tr class="separator:a85b38c5e9e5989ba8c1fec047e3cfbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a93aed5d539ef0a4c3ab325e6440d98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a0a93aed5d539ef0a4c3ab325e6440d98">CommandChannel</a> (QUuid sourceId, QString sourceType, QHostAddress serverAddress, quint16 serverPort_, QObject *parent=0)</td></tr>
<tr class="memdesc:a0a93aed5d539ef0a4c3ab325e6440d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a>.  <a href="#a0a93aed5d539ef0a4c3ab325e6440d98">More...</a><br /></td></tr>
<tr class="separator:a0a93aed5d539ef0a4c3ab325e6440d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af270c3f840dedc4d2d4f18d6471f5242"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af270c3f840dedc4d2d4f18d6471f5242"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#af270c3f840dedc4d2d4f18d6471f5242">~CommandChannel</a> ()</td></tr>
<tr class="memdesc:af270c3f840dedc4d2d4f18d6471f5242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to make sure that the Socket underlying this channel is closed before the channel is destroyed. <br /></td></tr>
<tr class="separator:af270c3f840dedc4d2d4f18d6471f5242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2178a704ecbacc3cc4b68af6949326d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a2178a704ecbacc3cc4b68af6949326d9">incomingResponsesWaiting</a> ()</td></tr>
<tr class="memdesc:a2178a704ecbacc3cc4b68af6949326d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the network for any new incoming responses, adds them to the incomingResponseQueue_, and returns the number of responses in the queue.  <a href="#a2178a704ecbacc3cc4b68af6949326d9">More...</a><br /></td></tr>
<tr class="separator:a2178a704ecbacc3cc4b68af6949326d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6805cc3415f144d03ae7e343df3d32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a5b6805cc3415f144d03ae7e343df3d32">sendCommand</a> (QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_command.html">Picto::ProtocolCommand</a> &gt; command)</td></tr>
<tr class="memdesc:a5b6805cc3415f144d03ae7e343df3d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a> over the channel.  <a href="#a5b6805cc3415f144d03ae7e343df3d32">More...</a><br /></td></tr>
<tr class="separator:a5b6805cc3415f144d03ae7e343df3d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6415c16c0bea0578876d13fe270074"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a1d6415c16c0bea0578876d13fe270074">sendRegisteredCommand</a> (QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_command.html">Picto::ProtocolCommand</a> &gt; command, bool enabledResend=true)</td></tr>
<tr class="memdesc:a1d6415c16c0bea0578876d13fe270074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a command and registers it so we can watch for a matching response.  <a href="#a1d6415c16c0bea0578876d13fe270074">More...</a><br /></td></tr>
<tr class="separator:a1d6415c16c0bea0578876d13fe270074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1735870ee016525f58b6c585fdad301"><td class="memItemLeft" align="right" valign="top">QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_response.html">ProtocolResponse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#af1735870ee016525f58b6c585fdad301">getResponse</a> ()</td></tr>
<tr class="memdesc:af1735870ee016525f58b6c585fdad301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top response in the incomingResponseQueue_ and removes it from the queue.  <a href="#af1735870ee016525f58b6c585fdad301">More...</a><br /></td></tr>
<tr class="separator:af1735870ee016525f58b6c585fdad301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0749ef93c32a3f070dadd4e793355f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a1a0749ef93c32a3f070dadd4e793355f">setStatusManager</a> (QSharedPointer&lt; <a class="el" href="class_component_status_manager.html">ComponentStatusManager</a> &gt; statusManager)</td></tr>
<tr class="memdesc:a1a0749ef93c32a3f070dadd4e793355f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When used in the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a>, the <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> works closely with a <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a> object. This sets a stored pointer to that object.  <a href="#a1a0749ef93c32a3f070dadd4e793355f">More...</a><br /></td></tr>
<tr class="separator:a1a0749ef93c32a3f070dadd4e793355f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c88699a561e49f70b028122b9c60b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a42c88699a561e49f70b028122b9c60b1">addResponseHandler</a> (QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_response_handler.html">ProtocolResponseHandler</a> &gt; responseHandler, bool replaceExisting=true)</td></tr>
<tr class="memdesc:a42c88699a561e49f70b028122b9c60b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> maintains a table of <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> objects that take care of handling responses from the server that include commands. This function adds a <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> to that table.  <a href="#a42c88699a561e49f70b028122b9c60b1">More...</a><br /></td></tr>
<tr class="separator:a42c88699a561e49f70b028122b9c60b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe619791fb542563544ecf50628238b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b">processResponses</a> (int timeoutMs)</td></tr>
<tr class="memdesc:aafe619791fb542563544ecf50628238b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a REALLY IMPORTANT function that reads <a class="el" href="struct_picto_1_1_protocol_response.html" title="A response, issued as the result of a command. ">ProtocolResponse</a> objects coming in from the server, maps them to appropriate <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> objects and tells them to handle the response. Its pretty much the main event loop of <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> objects. READ THE DETAILS.....  <a href="#aafe619791fb542563544ecf50628238b">More...</a><br /></td></tr>
<tr class="separator:aafe619791fb542563544ecf50628238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa109c33aeb66291ba15979378fa0d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fa109c33aeb66291ba15979378fa0d5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a1fa109c33aeb66291ba15979378fa0d5">numIncomingResponses</a> ()</td></tr>
<tr class="memdesc:a1fa109c33aeb66291ba15979378fa0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="struct_picto_1_1_protocol_response.html" title="A response, issued as the result of a command. ">ProtocolResponse</a> objects that were recieved over the socket but not yet processed. <br /></td></tr>
<tr class="separator:a1fa109c33aeb66291ba15979378fa0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc000fefa9fa963e93aff6e067bca69c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#adc000fefa9fa963e93aff6e067bca69c">waitForResponse</a> (int timeout=0)</td></tr>
<tr class="memdesc:adc000fefa9fa963e93aff6e067bca69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits up to the input timeout (in ms) for the command channel to have a response to process.  <a href="#adc000fefa9fa963e93aff6e067bca69c">More...</a><br /></td></tr>
<tr class="separator:adc000fefa9fa963e93aff6e067bca69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995ed26dfa4a7c97b2961279aec5f821"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a995ed26dfa4a7c97b2961279aec5f821"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a995ed26dfa4a7c97b2961279aec5f821">pendingResponses</a> ()</td></tr>
<tr class="memdesc:a995ed26dfa4a7c97b2961279aec5f821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every time we send a registered command, we keep it in a lookup table until a matching response comes in indicating that it was received and processed. This function returns the number of commands of this type that are waiting for responses. <br /></td></tr>
<tr class="separator:a995ed26dfa4a7c97b2961279aec5f821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3231cb5461098aea05caea3755901d28"><td class="memItemLeft" align="right" valign="top">QDateTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a3231cb5461098aea05caea3755901d28">resendPendingCommands</a> ()</td></tr>
<tr class="memdesc:a3231cb5461098aea05caea3755901d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resends all registered commands for which responses have not been received with this object's resendPendingInterval_.  <a href="#a3231cb5461098aea05caea3755901d28">More...</a><br /></td></tr>
<tr class="separator:a3231cb5461098aea05caea3755901d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5523a5b477f21ba2c88160e67ff7a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#ab5523a5b477f21ba2c88160e67ff7a8b">setSessionId</a> (QUuid sessionId)</td></tr>
<tr class="memdesc:ab5523a5b477f21ba2c88160e67ff7a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Session ID for which this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> will be sending data.  <a href="#ab5523a5b477f21ba2c88160e67ff7a8b">More...</a><br /></td></tr>
<tr class="separator:ab5523a5b477f21ba2c88160e67ff7a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146335a81b0ef524aa8291b3f6dc9721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a146335a81b0ef524aa8291b3f6dc9721"></a>
QUuid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a146335a81b0ef524aa8291b3f6dc9721">getSessionId</a> ()</td></tr>
<tr class="memdesc:a146335a81b0ef524aa8291b3f6dc9721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Session Id of the session making use of this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a>. <br /></td></tr>
<tr class="separator:a146335a81b0ef524aa8291b3f6dc9721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e492ff5325ea3c0bbfe22bbe02863f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a80e492ff5325ea3c0bbfe22bbe02863f">clearSessionId</a> ()</td></tr>
<tr class="memdesc:a80e492ff5325ea3c0bbfe22bbe02863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any Session ID that this Command Channel had stored.  <a href="#a80e492ff5325ea3c0bbfe22bbe02863f">More...</a><br /></td></tr>
<tr class="separator:a80e492ff5325ea3c0bbfe22bbe02863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec9175282cb98e99ece960376f3da12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ec9175282cb98e99ece960376f3da12"></a>
<a class="el" href="class_picto_1_1_command_channel.html#ab7d91aac6340369c17e2bd2be8a465db">ChannelStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a0ec9175282cb98e99ece960376f3da12">getChannelStatus</a> ()</td></tr>
<tr class="memdesc:a0ec9175282cb98e99ece960376f3da12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current ChannelStatus of this channel. <br /></td></tr>
<tr class="separator:a0ec9175282cb98e99ece960376f3da12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa081f7ae579624416e409f2cdd69b456"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa081f7ae579624416e409f2cdd69b456"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#aa081f7ae579624416e409f2cdd69b456">isConnected</a> ()</td></tr>
<tr class="memdesc:aa081f7ae579624416e409f2cdd69b456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this channel is currently connected to the server (ie. <a class="el" href="class_picto_1_1_command_channel.html#a0ec9175282cb98e99ece960376f3da12" title="Returns the current ChannelStatus of this channel. ">getChannelStatus()</a> returns connected. <br /></td></tr>
<tr class="separator:aa081f7ae579624416e409f2cdd69b456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785fa9b2dccc12b6419dc9d8be3d2e21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a785fa9b2dccc12b6419dc9d8be3d2e21">assureConnection</a> (int acceptableTimeoutMs=0)</td></tr>
<tr class="memdesc:a785fa9b2dccc12b6419dc9d8be3d2e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the channel is connected, and if not starts the reconnection process, waiting up to the input number of ms for it to complete. returns true if connected, false if disconnected.  <a href="#a785fa9b2dccc12b6419dc9d8be3d2e21">More...</a><br /></td></tr>
<tr class="separator:a785fa9b2dccc12b6419dc9d8be3d2e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3c41d62b857a6ba81c55ab6aaa4a8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a9f3c41d62b857a6ba81c55ab6aaa4a8f">closeChannel</a> ()</td></tr>
<tr class="memdesc:a9f3c41d62b857a6ba81c55ab6aaa4a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the channel (also called from the destructor)  <a href="#a9f3c41d62b857a6ba81c55ab6aaa4a8f">More...</a><br /></td></tr>
<tr class="separator:a9f3c41d62b857a6ba81c55ab6aaa4a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa613e72eff7d7b2b01707350c5ca588"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa613e72eff7d7b2b01707350c5ca588"></a>
QHostAddress&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#aaa613e72eff7d7b2b01707350c5ca588">getIpAddress</a> ()</td></tr>
<tr class="memdesc:aaa613e72eff7d7b2b01707350c5ca588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IP Address from which this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> is communicating. <br /></td></tr>
<tr class="separator:aaa613e72eff7d7b2b01707350c5ca588"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-slots"></a>
Private Slots</h2></td></tr>
<tr class="memitem:af5a2baf25d6c802938a27a22e6ad8a65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#af5a2baf25d6c802938a27a22e6ad8a65">disconnectHandler</a> ()</td></tr>
<tr class="separator:af5a2baf25d6c802938a27a22e6ad8a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aad69d50e86fad7d3fdd9008534c3b258"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad69d50e86fad7d3fdd9008534c3b258"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readIncomingCommand</b> ()</td></tr>
<tr class="separator:aad69d50e86fad7d3fdd9008534c3b258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ba381d8df348c6654548930f1bb77b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#a72ba381d8df348c6654548930f1bb77b">readIncomingResponse</a> ()</td></tr>
<tr class="memdesc:a72ba381d8df348c6654548930f1bb77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an incoming response and adds it to the incoming response queue. Removes any pending registered commands referenced by the response.  <a href="#a72ba381d8df348c6654548930f1bb77b">More...</a><br /></td></tr>
<tr class="separator:a72ba381d8df348c6654548930f1bb77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7142df6e5502b44b986e5be02dbfeae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_picto_1_1_command_channel.html#ab7142df6e5502b44b986e5be02dbfeae">discoverServer</a> (int timeoutMs)</td></tr>
<tr class="memdesc:ab7142df6e5502b44b986e5be02dbfeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to discover the Picto <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a>'s address and port for the TCPSocket connection.  <a href="#ab7142df6e5502b44b986e5be02dbfeae">More...</a><br /></td></tr>
<tr class="separator:ab7142df6e5502b44b986e5be02dbfeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5d1e98ce4e0d8263c63f405fa4203747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d1e98ce4e0d8263c63f405fa4203747"></a>
QHostAddress&#160;</td><td class="memItemRight" valign="bottom"><b>serverAddr_</b></td></tr>
<tr class="separator:a5d1e98ce4e0d8263c63f405fa4203747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565095124ef03ea95f0a52a4471930fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a565095124ef03ea95f0a52a4471930fb"></a>
quint16&#160;</td><td class="memItemRight" valign="bottom"><b>serverPort_</b></td></tr>
<tr class="separator:a565095124ef03ea95f0a52a4471930fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a382f6336172e4586c69c205292d61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54a382f6336172e4586c69c205292d61"></a>
QSharedPointer&lt; QTcpSocket &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>consumerSocket_</b></td></tr>
<tr class="separator:a54a382f6336172e4586c69c205292d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0408e0c70ecec0c939e5dfe131da0d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0408e0c70ecec0c939e5dfe131da0d3"></a>
QSharedPointer&lt; QUdpSocket &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>discoverySocket_</b></td></tr>
<tr class="separator:ad0408e0c70ecec0c939e5dfe131da0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672888f03ffd805a26eddfa72eb9e90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af672888f03ffd805a26eddfa72eb9e90"></a>
quint16&#160;</td><td class="memItemRight" valign="bottom"><b>discoveryPort_</b></td></tr>
<tr class="separator:af672888f03ffd805a26eddfa72eb9e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff25b4f77ce108a57b8329a8096a63c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeff25b4f77ce108a57b8329a8096a63c"></a>
<a class="el" href="class_picto_1_1_command_channel.html#ab7d91aac6340369c17e2bd2be8a465db">ChannelStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><b>status_</b></td></tr>
<tr class="separator:aeff25b4f77ce108a57b8329a8096a63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249069cab29feae53508fe69a23e4611"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a249069cab29feae53508fe69a23e4611"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>reconnect_</b></td></tr>
<tr class="separator:a249069cab29feae53508fe69a23e4611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f24a182dbc81ce3cad7e8e11d522fc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f24a182dbc81ce3cad7e8e11d522fc9"></a>
qulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>currRegCmdID_</b></td></tr>
<tr class="separator:a4f24a182dbc81ce3cad7e8e11d522fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61beab32a17e702a05034c91035883a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae61beab32a17e702a05034c91035883a"></a>
QList&lt; QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_response.html">ProtocolResponse</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>incomingResponseQueue_</b></td></tr>
<tr class="separator:ae61beab32a17e702a05034c91035883a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7df513ff90404e151a5a8e30698274"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf7df513ff90404e151a5a8e30698274"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><b>multipartBoundary_</b></td></tr>
<tr class="separator:adf7df513ff90404e151a5a8e30698274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d8adab6b51bd8e999a7cde54ceebe9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43d8adab6b51bd8e999a7cde54ceebe9"></a>
QMap&lt; qulonglong, QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_command.html">ProtocolCommand</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pendingCommands_</b></td></tr>
<tr class="separator:a43d8adab6b51bd8e999a7cde54ceebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9474d57015bbabdc9cdf68e4d4836b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c9474d57015bbabdc9cdf68e4d4836b"></a>
QUuid&#160;</td><td class="memItemRight" valign="bottom"><b>sessionId_</b></td></tr>
<tr class="separator:a4c9474d57015bbabdc9cdf68e4d4836b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb04d55659b7c41a40d4674944e7384c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb04d55659b7c41a40d4674944e7384c"></a>
QUuid&#160;</td><td class="memItemRight" valign="bottom"><b>sourceId_</b></td></tr>
<tr class="separator:acb04d55659b7c41a40d4674944e7384c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb693bad013a90d419eba27d122b8e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fb693bad013a90d419eba27d122b8e0"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><b>sourceType_</b></td></tr>
<tr class="separator:a7fb693bad013a90d419eba27d122b8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad163fff1bdcfc5bfb72fe535a5e555c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad163fff1bdcfc5bfb72fe535a5e555c4"></a>
QWeakPointer&lt; <a class="el" href="class_component_status_manager.html">ComponentStatusManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>statusManager_</b></td></tr>
<tr class="separator:ad163fff1bdcfc5bfb72fe535a5e555c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7b85426d5bdeaf219caa5410ec43a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b7b85426d5bdeaf219caa5410ec43a5"></a>
QMap&lt; QString, QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_response_handler.html">ProtocolResponseHandler</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>responseHandlerMap_</b></td></tr>
<tr class="separator:a7b7b85426d5bdeaf219caa5410ec43a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f28e6f49f005a5666ba89084464a209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f28e6f49f005a5666ba89084464a209"></a>
QDateTime&#160;</td><td class="memItemRight" valign="bottom"><b>discoverMsgSentTime_</b></td></tr>
<tr class="separator:a2f28e6f49f005a5666ba89084464a209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76006aae3019ba49ebb7c5503010fa8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76006aae3019ba49ebb7c5503010fa8c"></a>
QDateTime&#160;</td><td class="memItemRight" valign="bottom"><b>earliestPendingCommand_</b></td></tr>
<tr class="separator:a76006aae3019ba49ebb7c5503010fa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7709a033854ceacfb9c40e49795679f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7709a033854ceacfb9c40e49795679f"></a>
QDateTime&#160;</td><td class="memItemRight" valign="bottom"><b>lastReconnectTime_</b></td></tr>
<tr class="separator:af7709a033854ceacfb9c40e49795679f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce9d754ac13d390642172a1fd7361ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acce9d754ac13d390642172a1fd7361ac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>resendPendingInterval_</b></td></tr>
<tr class="separator:acce9d754ac13d390642172a1fd7361ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958bcb849fe2a07d715addc3c6fc6a03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a958bcb849fe2a07d715addc3c6fc6a03"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>resendEnabled_</b></td></tr>
<tr class="separator:a958bcb849fe2a07d715addc3c6fc6a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A channel for sending/receiving commands/responses over the network. </p>
<p>This discussion needs to start with a warning. Warning! This is a very messy class. This class has a lot of history and its design has suffered significantly from that history... it needs to be fixed. I will write more about this at the end. But now, getting back to the description:</p>
<p>The <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> object abstracts the communication between any two devices which communicate via network protocols. For example, PictoDirector would use a <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> to send <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a> objects with behavioral data to the PictoServer.</p>
<p>The channel is bidirectional, but is intended to be used by the client in a client/server pair. The channel can send <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a> objects and receive <a class="el" href="struct_picto_1_1_protocol_response.html" title="A response, issued as the result of a command. ">ProtocolResponse</a> objects.</p>
<p>The <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> can be connected to a server in multiple ways:</p><ul>
<li>The <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> can be passed a host address and port in the constructor - Currently never used</li>
<li>The <a class="el" href="class_picto_1_1_command_channel.html#a785fa9b2dccc12b6419dc9d8be3d2e21" title="Checks the channel is connected, and if not starts the reconnection process, waiting up to the input ...">assureConnection()</a> function can be used (which internally calls <a class="el" href="class_picto_1_1_command_channel.html#ab7142df6e5502b44b986e5be02dbfeae" title="Attempts to discover the Picto Server&#39;s address and port for the TCPSocket connection. ">discoverServer()</a> to detect a Picto <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> and connect to it.</li>
</ul>
<p>To use the object, the owner calls the <a class="el" href="class_picto_1_1_command_channel.html#a2178a704ecbacc3cc4b68af6949326d9" title="Checks the network for any new incoming responses, adds them to the incomingResponseQueue_, and returns the number of responses in the queue. ">incomingResponsesWaiting()</a> function. This checks the command socket for any incoming data, and then reports back the number of responses queed up for processing. The readResponse() function can then be called for each item in the queue. For outgoing commands, the <a class="el" href="class_picto_1_1_command_channel.html#a5b6805cc3415f144d03ae7e343df3d32" title="Sends a ProtocolCommand over the channel. ">sendCommand()</a> function is called directly.</p>
<p>The <a class="el" href="class_picto_1_1_command_channel.html#a1d6415c16c0bea0578876d13fe270074" title="Sends a command and registers it so we can watch for a matching response. ">sendRegisteredCommand()</a> function can be used to keep track of which commands have been recieved and processed by the server. Registered commands for which responses were not received can be resent with <a class="el" href="class_picto_1_1_command_channel.html#a3231cb5461098aea05caea3755901d28" title="Resends all registered commands for which responses have not been received with this object&#39;s resendP...">resendPendingCommands()</a>. This system is currently used by <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> objects.</p>
<p>The <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> suffers significantly since it uses QTcpSockets to send commands over a network while for historical reasons, the heaviest users of the <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a>, <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> objects don't use the Qt Event Loop which is really required for QTcpSockets to run smoothly. For this reason, there is a lot of general code complexity and round about function based processing for things like assuring a network connection ( <a class="el" href="class_picto_1_1_command_channel.html#a785fa9b2dccc12b6419dc9d8be3d2e21" title="Checks the channel is connected, and if not starts the reconnection process, waiting up to the input ...">assureConnection()</a> ), discovering a Picto <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> IP Address and Port ( <a class="el" href="class_picto_1_1_command_channel.html#ab7142df6e5502b44b986e5be02dbfeae" title="Attempts to discover the Picto Server&#39;s address and port for the TCPSocket connection. ">discoverServer()</a> ) and making sure server <a class="el" href="struct_picto_1_1_protocol_response.html" title="A response, issued as the result of a command. ">ProtocolResponse</a> messages are correctly handled ( <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">processResponses()</a> ). This also leads to interfaces to components like ProtocolResponseHander objects and <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a> objects that the <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> should really know nothing about. In an ideal world, all of these types of things would be handled by signals and slots that would be managed from the Qt Event Loop. For more detail on this issue, see the functions mentioned above, particularly <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">processResponses()</a>.</p>
<p>Refactoring of the Picto experimental run system to use the Qt Event loop and cleaning up this class accordingly should be considered a Priority. Until that happens, we can easily point to using the <a class="el" href="class_picto_1_1_command_channel.html#a785fa9b2dccc12b6419dc9d8be3d2e21" title="Checks the channel is connected, and if not starts the reconnection process, waiting up to the input ...">assureConnection()</a>, <a class="el" href="class_picto_1_1_command_channel.html#a5b6805cc3415f144d03ae7e343df3d32" title="Sends a ProtocolCommand over the channel. ">sendCommand()</a>, <a class="el" href="class_picto_1_1_command_channel.html#adc000fefa9fa963e93aff6e067bca69c" title="Waits up to the input timeout (in ms) for the command channel to have a response to process...">waitForResponse()</a>, <a class="el" href="class_picto_1_1_command_channel.html#a995ed26dfa4a7c97b2961279aec5f821" title="Every time we send a registered command, we keep it in a lookup table until a matching response comes...">pendingResponses()</a>, <a class="el" href="class_picto_1_1_command_channel.html#a1fa109c33aeb66291ba15979378fa0d5" title="Returns the number of ProtocolResponse objects that were recieved over the socket but not yet process...">numIncomingResponses()</a>, and <a class="el" href="class_picto_1_1_command_channel.html#af1735870ee016525f58b6c585fdad301" title="Returns the top response in the incomingResponseQueue_ and removes it from the queue. ">getResponse()</a> functions to send a <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a>, wait for, and get a returned <a class="el" href="struct_picto_1_1_protocol_response.html" title="A response, issued as the result of a command. ">ProtocolResponse</a>. Things start getting complicated pretty fast though, and its best at this point to just look at an existing example of <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> usage in the Picto Code, like the <a class="el" href="class_remote_viewer.html" title="This allows Operators to view and control a remotely running Experimental Session. ">RemoteViewer</a>. <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> objects use the <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> in a particularly central and complex fashion. It is for <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> objects that the <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> needs to include pointers to <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> and <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a> objects. For further incite into what is going on here, look at the <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">processResponses()</a> documentation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">processResponses()</a>, <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a>, <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a>, <a class="el" href="class_picto_1_1_engine_1_1_picto_engine.html" title="Runs a Picto Experiment. ">Engine::PictoEngine</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Trevor Stavropoulos, Joey Schnurr, Mark Hammond, Matt Gay </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2009-2015 </dd></dl>

<p>Definition at line <a class="el" href="_command_channel_8h_source.html#l00073">73</a> of file <a class="el" href="_command_channel_8h_source.html">CommandChannel.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ab7d91aac6340369c17e2bd2be8a465db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_picto_1_1_command_channel.html#ab7d91aac6340369c17e2bd2be8a465db">Picto::CommandChannel::ChannelStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The current status of this channel. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab7d91aac6340369c17e2bd2be8a465dbacab8110f599c9fb57e044a328111b2c6"></a>connected&#160;</td><td class="fielddoc">
<p>This channel is currently connected to the server. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab7d91aac6340369c17e2bd2be8a465dbad0e2834ef8ac8d240b15e4f43b4bdc46"></a>disconnected&#160;</td><td class="fielddoc">
<p>This channel is not currently connected to the server. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_command_channel_8h_source.html#l00113">113</a> of file <a class="el" href="_command_channel_8h_source.html">CommandChannel.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a85b38c5e9e5989ba8c1fec047e3cfbea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Picto::CommandChannel::CommandChannel </td>
          <td>(</td>
          <td class="paramtype">QUuid&#160;</td>
          <td class="paramname"><em>sourceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a>. </p>
<p>The input sourceId is a unique ID that will be used to identify the owner of this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> in all communications. The sourceType input is a string describing the type of application that is using this command channel (ie. "DIRECTOR"). The source type is also recorded in all communications. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00018">18</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a93aed5d539ef0a4c3ab325e6440d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Picto::CommandChannel::CommandChannel </td>
          <td>(</td>
          <td class="paramtype">QUuid&#160;</td>
          <td class="paramname"><em>sourceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>sourceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QHostAddress&#160;</td>
          <td class="paramname"><em>serverAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>serverPort_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a>. </p>
<p>The input sourceId is a unique ID that will be used to identify the owner of this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> in all communications. The sourceType input is a string describing the type of application that is using this command channel (ie. "DIRECTOR"). The source type is also recorded in all communications. The input serverPort is the port on which communication will occur with the server, if it is known at the time that this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> is constructed. </p><dl class="section note"><dt>Note</dt><dd>This constructor does not appear to ever be used in Picto and should probably be removed. </dd></dl>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00048">48</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a42c88699a561e49f70b028122b9c60b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picto::CommandChannel::addResponseHandler </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_response_handler.html">ProtocolResponseHandler</a> &gt;&#160;</td>
          <td class="paramname"><em>responseHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceExisting</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> maintains a table of <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> objects that take care of handling responses from the server that include commands. This function adds a <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> to that table. </p>
<p>The <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> table is indexed by the response directive that each <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> knows how to deal with. That way, when new responses come in, in <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">processResponses()</a> the appropriate handler can be quickly found and used. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00153">153</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a785fa9b2dccc12b6419dc9d8be3d2e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Picto::CommandChannel::assureConnection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>acceptableTimeoutMs</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the channel is connected, and if not starts the reconnection process, waiting up to the input number of ms for it to complete. returns true if connected, false if disconnected. </p>
<p>This call only blocks for up to the input number of ms. It checks for a connection every time the function is called and if there is no connection, it attempts to reconnect by using <a class="el" href="class_picto_1_1_command_channel.html#ab7142df6e5502b44b986e5be02dbfeae" title="Attempts to discover the Picto Server&#39;s address and port for the TCPSocket connection. ">discoverServer()</a> and QTcpSocket::connectToHost(). If there is an attached Status Manager, its status (disconnected or idle) is set automatically as part of this function. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00434">434</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80e492ff5325ea3c0bbfe22bbe02863f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picto::CommandChannel::clearSessionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes any Session ID that this Command Channel had stored. </p>
<p>This function does not appear to be used currently. I'm not sure that it would ever really be useful. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00753">753</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f3c41d62b857a6ba81c55ab6aaa4a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picto::CommandChannel::closeChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the channel (also called from the destructor) </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00097">97</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5a2baf25d6c802938a27a22e6ad8a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Picto::CommandChannel::disconnectHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">slot</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>when a socket emits a disconnect signal</p>
<p>There are two scenarios in which this handler gets called:</p><ol type="1">
<li>We are closing the channel</li>
<li>There was some sort of error In the first case, we should let the disconnect happen, but in the second case we need to try to reconnect immediately. The reconnect_ variable is used to differentiate between the two situations. <dl class="section see"><dt>See also</dt><dd><a class="el" href="class_picto_1_1_command_channel.html#a785fa9b2dccc12b6419dc9d8be3d2e21" title="Checks the channel is connected, and if not starts the reconnection process, waiting up to the input ...">assureConnection()</a> </dd></dl>
</li>
</ol>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00657">657</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7142df6e5502b44b986e5be02dbfeae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Picto::CommandChannel::discoverServer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to discover the Picto <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a>'s address and port for the TCPSocket connection. </p>
<p>The function sends a UDP discover message to the server up to once for each 10 seconds during which it is called without completing server discovery. Each time is is called the function checks for a response to the UDP discover message indicating the servers ip address and port. If this function is called with a timeout less than or equal to zero it will do nothing and return false. If the server is discovered, the function updates all of the channel's data fields accordingly and returns true. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00497">497</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af1735870ee016525f58b6c585fdad301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_response.html">ProtocolResponse</a> &gt; Picto::CommandChannel::getResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the top response in the incomingResponseQueue_ and removes it from the queue. </p>
<p>If the incomingResponseQueue_ is empty, an empty shared pointer will be returned. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00127">127</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2178a704ecbacc3cc4b68af6949326d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Picto::CommandChannel::incomingResponsesWaiting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the network for any new incoming responses, adds them to the incomingResponseQueue_, and returns the number of responses in the queue. </p>
<p>Effectively, this function is just polling for the latest responses, then returning <a class="el" href="class_picto_1_1_command_channel.html#a1fa109c33aeb66291ba15979378fa0d5" title="Returns the number of ProtocolResponse objects that were recieved over the socket but not yet process...">numIncomingResponses()</a>. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00114">114</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aafe619791fb542563544ecf50628238b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Picto::CommandChannel::processResponses </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a REALLY IMPORTANT function that reads <a class="el" href="struct_picto_1_1_protocol_response.html" title="A response, issued as the result of a command. ">ProtocolResponse</a> objects coming in from the server, maps them to appropriate <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> objects and tells them to handle the response. Its pretty much the main event loop of <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> objects. READ THE DETAILS..... </p>
<p>This is one of those functions, the ones that are hiding in the middle of a huge stack of obscure code looking like any other function even though they are actually essentially the masters of the entire application. The history behind this function is that long, long ago, before there were smartphones, computers were pretty fast, but not quite so fast as they are now. At that point there was a concern that if we were to use Qt's event loop architecture (which is well designed and everything but required when you build with Qt) since we didn't have total control of what was happening behind the scenes in the application code, Qt might go and spend 100 ms trying to handle some random windows event that we don't care about and cause an experiment to skip a bunch of frames which would make data about things like subject response times to stimuli less reliable, or ruin timing in precisely timed states. For those reasons, the decision was made to work outside of the Qt event loop and run everything in our own loop thereby allowing us to ignore all machine events apart from data coming in over a socket from the server. At this point, though I haven't performed any tests, I believe that decision is obsolete. Processors are very fast, Picto is running on fairly clean machines that don't have lots of other background things going on, and if the core i5 processors that we are using in Pictoboxes are good enough to run many modern video games in all of their 3d, shaded, ray traced glory at 60 frames per second, they can probably handle our little circles and squares without too much trouble, even if we do use the QT event loop. Added to this is a recent paper: <a href="http://jn.physiology.org/content/109/1/249.full.pdf+html">http://jn.physiology.org/content/109/1/249.full.pdf+html</a> discussing the monkey logic software and how the Matlab language interpreter is now fast enough on a core i5 processor to acceptably deliver stimuli and track responses. Since we are working in C++ and they are working in Matlab. If they can do it, it would be difficult to imagine that our code couldn't do it, even with a QT event loop running. For this reason, I hope that at some point, someone will refactor the code for ComponentInterfaces (<a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> and Proxy) such that they make use of the Qt event loop and can do away with this strange event loop inside the <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a>. As part of this, the PictoEngine and <a class="el" href="class_picto_1_1_experiment.html" title="The Experiment object contains the complete definition of an Experiment for running in the Director...">Experiment</a> should be refactored as well so that we never spend more than one frame with control inside the experiment. Each frame, control should pass down from the Qt event loop, into the current state, the frame should be presented and time stamped, and control should return to the event loop for the next frame. Obviously this will need to be tested, but for normal experiments we should not run into problems. We can also add code to make Picto perform self checks for missed frames, verifying that the time span between control entery into the frame presentation code from one call to the next has very low variance. This would help experiment designers catch design errors like "if(var i=0 ;i&lt;10;i--){...}" which would innevitably lead to skipped frames.</p>
<p>In any event, the purpose of this documentation is to describe the current code, and so...</p>
<p>This function essentially became the Event Loop because it handles responses to server commands, and in the end, <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> objects are essentially slaves to the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a>. ComponentInterfaces wait for a NEWSESSION command, they wait for a start command, they wait for the server to end the session. For that reason, all Director/Proxy <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> code is functionally placed underneath this one function that handles the server responses. This is somewhat confusing. We just said that the Director/Proxy are slaves to the server. Shouldn't they be the ones supplying the responses? The answer to this is that they gather so much data and have precise timing requirements such they need to get rid of the data on their schedule. That means that they send the commands to the server whenever they need to and this happens frequently enough that the server can send its logical commands back inside 'responses' to the Director/Proxy's network commands and there is still never much of a noticable lag. When the Director/Proxy are idle, they still send periodic update commands to tell the server that thet are ready to start a session, so the server always has some response on which to piggyback a logical command.</p>
<p>In summary, rewrite the <a class="el" href="class_component_interface.html" title="A base class for high level components that take orders from the Picto server and provide it with ses...">ComponentInterface</a> / Experimental run system please!!!!! and the activities of this function are as follows:</p><ul>
<li>Gather responses to commands sent on the channel. Hhandle them using ProtocolResponseHander objects and mark off any registered commands that they match.</li>
<li>Make sure that we are still connected to the server, and attempt to reconnect if necessary.</li>
<li>Resend any registered commands for whom no matching responses have been received verifying that the commands were processed and their data saved. This continues until either the input number of timeoutMs milliseconds has been passed, or if -1 is input (indicating that the function never times out) this looping functionality continues until the statusManager_.toStrongRef()-&gt;exitTriggered() function returns true (which always causes the function to end).</li>
</ul>
<p>The function returns true if there are no pending responses left from the server. If there are still some responses left that were not processed, false is returned. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00206">206</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72ba381d8df348c6654548930f1bb77b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Picto::CommandChannel::readIncomingResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an incoming response and adds it to the incoming response queue. Removes any pending registered commands referenced by the response. </p>
<p>The command channel offers a registered command system. Registered are sent to the server with a "Command-ID" and a copy of the registered command is stored in a lookup table, indexed under its command id for resending if receipt is never verified within a present time window. The server keeps track of the command ids of command messages that it recieves and in its response messages sends a list of all command-ids who's data was not only received, but also saved to disk. When the responses are recieved by the registered commands sender, the original registered commands are removed from the lookup table. By using this system, we are assured that all registered commands will be saved to disk, even if someone does something crazy like restart the server in the middle of an experiment. Unless something catastrophic occurs that causes the server to go offline so long that the sender machine's heap overflows, we can be assured that data will be secure.</p>
<p>In this function, we read in all incoming responses. We check them for Command-Ids and removed all registered commands with those IDs from their lookup table. We then add the responses to an incoming response queue for processing by a <a class="el" href="struct_picto_1_1_protocol_response_handler.html" title="A base class for objects that handle ProtocolResponses coming in over the network in response to prev...">ProtocolResponseHandler</a> in the <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">processResponses()</a> function.</p>
<p>This function also handles the Picto Auto-update system. Whenever a response is received from the <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a>, it is checked for the version of the Picto server that sent it. If the Picto <a class="el" href="class_server.html" title="The Server object managing the actual incoming connections and ServerThread generation for the PictoS...">Server</a> Version is newer than the version of the local application installation, the <a class="el" href="class_update_downloader.html" title="A singleton class used to check for and automatically update to a newer version of the Picto Applicat...">UpdateDownloader</a> object is created and used to automatically update and restart the application containing this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a>. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00340">340</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3231cb5461098aea05caea3755901d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDateTime Picto::CommandChannel::resendPendingCommands </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resends all registered commands for which responses have not been received with this object's resendPendingInterval_. </p>
<p>Every time a registered command is sent, it is added to the list of pending commands. When a registered response is received, the corresponding command is removed from that list. This function resends all of the registered commands that were sent over resendPendingInterval_ seconds ago and have not yet had responses received.</p>
<p>The function checks which command will need to be resent next assuming that no response for it is received in time. It returns a QDateTime that indicates when the that command was sent originally so that the caller can plan when to next call this function. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">processResponses()</a> </dd></dl>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00700">700</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b6805cc3415f144d03ae7e343df3d32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Picto::CommandChannel::sendCommand </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_command.html">Picto::ProtocolCommand</a> &gt;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a> over the channel. </p>
<p>The following fields are automatically added to the <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a> before it is sent</p><ul>
<li>Source-ID: The unique ID of the device sending this message.</li>
<li>Source-Type: A string indicating the type of device that is sending this message (ie. DIRECTOR).</li>
<li>Session-ID: The unique Session Id of the Session to which this <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a> is relevant Returns true if the command is sent succesfully, false otherwise. <dl class="section note"><dt>Note</dt><dd>This function's returning true does not indicate that the receiver recieved the <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a>, only that it was succesfully sent. For a way to asynhronously be sure that the receiver recieved and saved that data included in a <a class="el" href="struct_picto_1_1_protocol_command.html" title="Represents a command in either the PICTO or HTTP protocols. ">ProtocolCommand</a>, use <a class="el" href="class_picto_1_1_command_channel.html#a1d6415c16c0bea0578876d13fe270074" title="Sends a command and registers it so we can watch for a matching response. ">sendRegisteredCommand()</a>. </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00593">593</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d6415c16c0bea0578876d13fe270074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Picto::CommandChannel::sendRegisteredCommand </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="struct_picto_1_1_protocol_command.html">Picto::ProtocolCommand</a> &gt;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabledResend</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a command and registers it so we can watch for a matching response. </p>
<p>This function is used when you want to be able to check at a later time to determine if a response has been issued for your command. A command sent this way has a "Command-ID" field appended. The command is also added to the pending commands lookup table (using the Command-ID UUID as a key). Sending a command as "registered" allows us to see if a response was received for that command with its included data saved. We can then resend any commands which didn't receive responses in a defined time window. For more detail on how registered commands and their responses are handled, see <a class="el" href="class_picto_1_1_command_channel.html#a72ba381d8df348c6654548930f1bb77b" title="Reads an incoming response and adds it to the incoming response queue. Removes any pending registered...">readIncomingResponse()</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_picto_1_1_command_channel.html#a72ba381d8df348c6654548930f1bb77b" title="Reads an incoming response and adds it to the incoming response queue. Removes any pending registered...">readIncomingResponse()</a> </dd></dl>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00636">636</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5523a5b477f21ba2c88160e67ff7a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picto::CommandChannel::setSessionId </td>
          <td>(</td>
          <td class="paramtype">QUuid&#160;</td>
          <td class="paramname"><em>sessionId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Session ID for which this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> will be sending data. </p>
<p>The Session ID is written to any attached <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a>. Command-ID values for registered commands are also reset back to 1 since they only need to be unique on a per-session bases. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00740">740</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a0749ef93c32a3f070dadd4e793355f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Picto::CommandChannel::setStatusManager </td>
          <td>(</td>
          <td class="paramtype">QSharedPointer&lt; <a class="el" href="class_component_status_manager.html">ComponentStatusManager</a> &gt;&#160;</td>
          <td class="paramname"><em>statusManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When used in the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a>, the <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> works closely with a <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a> object. This sets a stored pointer to that object. </p>
<p>Since the <a class="el" href="class_director.html" title="Defines an object that runs a Picto Experiment for a test subject, transmits experimental data to the...">Director</a> works outside of the Qt Event loop,things get a little hairy when it comes to sockets which by their very nature like to work in the background while other things are happening. For that reason, the <a class="el" href="class_picto_1_1_command_channel.html#aafe619791fb542563544ecf50628238b" title="This is a REALLY IMPORTANT function that reads ProtocolResponse objects coming in from the server...">processResponses()</a> function ends up becoming a kind of event loop since it is called frequently, and this function allows it to tell the <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a> to update. Storing a pointer to the <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a> also allows this <a class="el" href="class_picto_1_1_command_channel.html" title="A channel for sending/receiving commands/responses over the network. ">CommandChannel</a> to let the <a class="el" href="class_component_status_manager.html" title="Handles overall status operations for a ComponentInterface object. ">ComponentStatusManager</a> know when certain changes occur in connection status. </p>

<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00142">142</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc000fefa9fa963e93aff6e067bca69c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Picto::CommandChannel::waitForResponse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits up to the input timeout (in ms) for the command channel to have a response to process. </p>
<p>If the input is 0, this function is essentially equivalent to</p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <a class="code" href="class_picto_1_1_command_channel.html#a2178a704ecbacc3cc4b68af6949326d9">incomingResponsesWaiting</a>() &gt; 0; </div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="_command_channel_8cpp_source.html#l00287">287</a> of file <a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/common/network/<a class="el" href="_command_channel_8h_source.html">CommandChannel.h</a></li>
<li>source/common/network/<a class="el" href="_command_channel_8cpp_source.html">CommandChannel.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
