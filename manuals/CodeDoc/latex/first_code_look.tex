Becoming familiar with a new code base is always a challenge, and \hyperlink{namespace_picto}{Picto} is no exception. To help with this process, we have spent a great deal of time documenting \hyperlink{namespace_picto}{Picto} to the functional level. At this point, every funciton in \hyperlink{namespace_picto}{Picto} should be documented, as should all variables in the protected or public scope. Even with all of this information, you will need some guidance to get started. The purpose of this file is to provide some guidelines for getting started with the code base on your way to developing a deeper familiarity with it.\hypertarget{first_code_look_first_look_disclaimer}{}\section{Disclaimer}\label{first_code_look_first_look_disclaimer}
As one of the key elements in gaining an understanding of source code, we will start with a few key points about the \hyperlink{namespace_picto}{Picto} documentation of which you should be aware. First, keep in mind that we went over the entire code base in 12/2013-\/1/2014 to make sure that all function and class documentation was up to date. This projects was my (Joey's) last project in \hyperlink{namespace_picto}{Picto} and for that reason, in the interest of not braking something at the last minute, I was very careful to not change any actual code as I went through the process. This means that you will see lots of lines of documentation saying things like\-: \char`\"{}\-This is not used and you should probably remove it.\char`\"{} Sometimes the suggested changes are trivially easy, but in keeping with my \char`\"{}no changes\char`\"{} rule, I didn't change anything.

There are also some naming conventions that you should keep in mind in \hyperlink{namespace_picto}{Picto}. Typically, the person running an Experiment from the \hyperlink{class_remote_viewer}{Remote\-Viewer} is called the \char`\"{}\-Operator.\char`\"{} The person or animal being examined is called the \char`\"{}\-Test Subject\char`\"{}, \char`\"{}\-Subject\char`\"{} or sometimes but infrequently \char`\"{}\-User.\char`\"{} When we are talking about parts of the Workstation like the \hyperlink{class_replay_viewer}{Replay\-Viewer} or \hyperlink{class_test_viewer}{Test\-Viewer}, the researcher previously referred to as \char`\"{}\-Operator\char`\"{} might be referred to as the User (sorry, I know that is confusing). Also, sometimes that person is referred to as the \char`\"{}designer\char`\"{} since they designed the Experiment/\-Analysis. This can be a source of confusion due to the existance of a \hyperlink{class_designer}{Designer} class in the \hyperlink{namespace_picto}{Picto} source which is essentially the tool that the \char`\"{}designer person\char`\"{} uses to do the designing. Lastly, the actual Experiment/\-Analysis thing is often referred to as the \hyperlink{namespace_picto}{Picto} Design. This can be confusing because there is no actual Design class. When we say this, we are essentially referring to the root of the Experiment/\-Analysis tree. This is really the \hyperlink{class_picto_1_1_picto_data}{Picto\-::\-Picto\-Data} class. One might think of the \hyperlink{class_picto_1_1_design_root}{Picto\-::\-Design\-Root} as the \char`\"{}\-Design\char`\"{} as well; however, the \hyperlink{class_picto_1_1_design_root}{Picto\-::\-Design\-Root} is really more of a wrapper for the \hyperlink{class_picto_1_1_picto_data}{Picto\-::\-Picto\-Data} class. Hopefully, that will clarify some of the confusing terminology. Ideally we would have a Proof Editor that would go through all this documentation and normalize everything, but we don't and it would be quite a big job, so these types of things crop in. Also, keep in mind that Visual Studio completely rediculously has no built in spell-\/checker option even for comments \-:).\hypertarget{first_code_look_first_look_structure}{}\section{Structure}\label{first_code_look_first_look_structure}
\hyperlink{namespace_picto}{Picto} consists of four main applications, the Workstation, \hyperlink{class_server}{Server}, \hyperlink{class_director}{Director} and Proxy plus a sort of sub-\/application, the Embedded\-Front\-Panel application that controls the front panel and buttons on the Pictobox. All of these projects are defined within their own Visual Studio project files (.vcxproj) in their own sub-\/directories of the \hyperlink{namespace_picto}{Picto}\textbackslash{}src directory and included as part of the Picto.\-sln. The Visual Studio projects themselves are built by using 
\begin{DoxyCode}
ConfigureX86.cmd
tools\(\backslash\)qt.config\(\backslash\)mypaths.cmd
tools\(\backslash\)win.common\(\backslash\)GenerateBuildFiles.cmd
\end{DoxyCode}
 in the Visual Studio Command Prompt (See \hyperlink{build_environment_preparation}{Create a Picto Development Environment} for more details). The Generate\-Build\-Files.\-cmd itself uses the various .pro files scattered around the picto/src directory tree to figure out how to build the .vcxproj files. In this vain, be aware that whenever you want to add a file to one of the \hyperlink{namespace_picto}{Picto} projects, you need to do it by adding the header and cpp files to that project's .pro file and then rerunning the scripts outlined above.

As far as the individual \hyperlink{namespace_picto}{Picto} applications go, different approaches may be taken in building a familiarity with each one. We go through tips for starting out with each of the application code bases below.\hypertarget{first_code_look_first_look_Workstation}{}\section{Workstation}\label{first_code_look_first_look_Workstation}
Execution of the Workstation starts at the main method in \hyperlink{workstation_2main_8cpp}{workstation\textbackslash{}main.\-cpp}, but the Main\-Window.\-cpp is what really manages the main Workstation window. Start by looking at Main\-Window\-::create\-Viewers() and Main\-Window\-::change\-Mode(), these functions will give you as sense of how navigation works within the \hyperlink{class_main_window}{Main\-Window}. After that familiarize yourself with some of the other \hyperlink{class_main_window}{Main\-Window} functions, then move onto the classes that extend \hyperlink{class_viewer}{Viewer}, namely \hyperlink{class_remote_viewer}{Remote\-Viewer}, \hyperlink{class_replay_viewer}{Replay\-Viewer}, \hyperlink{class_state_edit_viewer}{State\-Edit\-Viewer}, and \hyperlink{class_test_viewer}{Test\-Viewer}, and work down from there. In particular, before working your way down to far, you will need to have a good sense of the Design Tree structure. Look at \hyperlink{class_picto_1_1_serializable}{Picto\-::\-Serializable}, \hyperlink{class_picto_1_1_asset}{Picto\-::\-Asset} and \hyperlink{class_picto_1_1_data_store}{Picto\-::\-Data\-Store} to get a sense of how serialization works. Take a look at \hyperlink{class_picto_1_1_property}{Picto\-::\-Property} and \hyperlink{class_picto_1_1_property_container}{Picto\-::\-Property\-Container} to understand where data is stored within \hyperlink{class_picto_1_1_data_store}{Picto\-::\-Data\-Store} objects at its lowest level. Next, start at \hyperlink{class_picto_1_1_experiment}{Picto\-::\-Experiment} and work your way down through its child \hyperlink{class_picto_1_1_task}{Picto\-::\-Task} object to \hyperlink{class_picto_1_1_state_machine}{Picto\-::\-State\-Machine}. \hyperlink{class_picto_1_1_state_machine}{Picto\-::\-State\-Machine} will give you a good sense of how control flow traverses through the \hyperlink{namespace_picto}{Picto} design. It will lead you to look at \hyperlink{class_picto_1_1_state}{Picto\-::\-State}, \hyperlink{class_picto_1_1_switch_element}{Picto\-::\-Switch\-Element} and other \hyperlink{class_picto_1_1_state_machine_element}{Picto\-::\-State\-Machine\-Element} objects. Once you are somewhat familiar with control flow, you can start working your way through the class inheritance tree that provides the functionality to things like \hyperlink{class_picto_1_1_state}{Picto\-::\-State}, \hyperlink{struct_picto_1_1_visual_element}{Picto\-::\-Visual\-Element}, etc.

Once you are familiar with the Design stucture, you can get back to the individual Viewers.
\begin{DoxyItemize}
\item The \hyperlink{class_state_edit_viewer}{State\-Edit\-Viewer} is really just a container for the Picto\-::\-Designer, so you'll want to look at that. When you are moving through all of the various widgets that the \hyperlink{class_designer}{Designer} uses, keep in mind that the Picto\-::\-Editor\-State is very important. It is the glue that holds the \hyperlink{class_designer}{Designer} together, allowing different widgets to communicate through the use of Qt Signals and Slots.
\item The \hyperlink{class_test_viewer}{Test\-Viewer} contains some complexity associated with selecting, setting up and running Analyses that can be a little distracting. When starting out, focus on the \hyperlink{class_test_playback_controller}{Test\-Playback\-Controller}. This is where the code that actually runs the Experiment Tasks lives.
\item Before looking through the \hyperlink{class_remote_viewer}{Remote\-Viewer}, look at the \hyperlink{class_picto_1_1_slave_experiment_driver}{Picto\-::\-Slave\-Experiment\-Driver}, \hyperlink{class_picto_1_1_state_updater}{Picto\-::\-State\-Updater} system and the Remote\-State\-Updater implementation of State\-Updater. These define the system that allows a master Experiment to control a slave, and the \hyperlink{class_remote_viewer}{Remote\-Viewer} uses them to run the Slave\-Experiment.
\item The \hyperlink{class_replay_viewer}{Replay\-Viewer} should be much clearer if you've gone through the \hyperlink{class_picto_1_1_slave_experiment_driver}{Picto\-::\-Slave\-Experiment\-Driver}, \hyperlink{class_picto_1_1_state_updater}{Picto\-::\-State\-Updater} system from the \hyperlink{class_remote_viewer}{Remote\-Viewer} guidelines. The \hyperlink{class_replay_viewer}{Replay\-Viewer} uses the same setup, except that the \hyperlink{class_picto_1_1_state_updater}{Picto\-::\-State\-Updater} in this case is a Playback\-State\-Updater controlled by a \hyperlink{class_playback_controller}{Playback\-Controller} that runs in its own thread. Again, there is some complexity associated with setting up, selecting and activating Analyses in the \hyperlink{class_replay_viewer}{Replay\-Viewer} code that can be distracting. If you can start with an understanding of how the \hyperlink{class_playback_controller}{Playback\-Controller} manages playback, it should make the \hyperlink{class_replay_viewer}{Replay\-Viewer} functionality a little bit clearer.
\end{DoxyItemize}\hypertarget{first_code_look_first_look_Server}{}\section{Server}\label{first_code_look_first_look_Server}
Parts of the \hyperlink{class_server}{Server} dealing with the actual sending an receiving of data over the network socket can get somewhat complicated. It is best to start with the high level function of the \hyperlink{class_server}{Server} and save its low level infrastructure for later. Start out with the assumption that the \hyperlink{class_server}{Server} recieves commands from the \hyperlink{class_director}{Director}, Proxy and Workstation, somehow processes them and sends them into the appropriate Protocol\-Command\-Handler. The classes that extend Protocol\-Command\-Handler can be found in server\textbackslash{}protocol. Focus on the main interfaces for the workstation\-: Start\-Session\-Command\-Handler and \hyperlink{struct_task_command_handler}{Task\-Command\-Handler}, and the main interfaces for the \hyperlink{class_director}{Director} and Proxy\-: \hyperlink{struct_put_data_command_handler}{Put\-Data\-Command\-Handler} and \hyperlink{struct_component_update_command_handler}{Component\-Update\-Command\-Handler}. These handlers will lead you into exploring the \hyperlink{class_connection_manager}{Connection\-Manager} class and the particularly important \hyperlink{class_session_info}{Session\-Info} class, which is really the heart of the \hyperlink{class_server}{Server} application.

Once you have gone through these pieces, you can look back at the \hyperlink{class_server}{Server} infrastructure\-: \hyperlink{class_server}{Server}, \hyperlink{class_server_thread}{Server\-Thread}, \hyperlink{struct_picto_1_1_protocol_command}{Picto\-::\-Protocol\-Command}, etc. The main method for the \hyperlink{class_server}{Server} application, in server\textbackslash{}main.\-cpp happens to be particularly complicated since the application can be run from both the command line and as a system service. It is not all that important that you understand the details of what is happening in server\textbackslash{}main.\-cpp unless you need to edit it. Don't spend too much time on it at this stage.\hypertarget{first_code_look_first_look_Director}{}\section{Director}\label{first_code_look_first_look_Director}
The \hyperlink{class_director}{Director} class inherits \hyperlink{class_component_interface}{Component\-Interface}, and the application is essentially started when \hyperlink{class_director}{Director}\textbackslash{}main.\-cpp calls Picto\-::\-Component\-Interface\-::activate(). It would be a good idea to start by looking through Picto\-::\-Component\-Interface. Next, look at \hyperlink{class_director}{Director} and try to get a good idea of how it is implementing the \hyperlink{class_component_interface}{Component\-Interface}. At this point, although it is somewhat counter intuitive, it would be a good idea to look at \hyperlink{class_picto_1_1_command_channel_aafe619791fb542563544ecf50628238b}{Picto\-::\-Command\-Channel\-::process\-Responses()}. This turns out to be a vitally important function for both the \hyperlink{class_director}{Director} and Proxy, more details are available in that function's documentation. After looking at the process\-Responses() function, check out the classes in director\textbackslash{}protocol that extend the various Protocol\-Response\-Handler classes along with Picto\-::\-Status\-Manager and \hyperlink{class_director_status_manager}{Director\-Status\-Manager}. In particular, \hyperlink{struct_director_start_response_handler}{Director\-Start\-Response\-Handler} does the work of actually running the Experiment Task.\hypertarget{first_code_look_first_look_Proxy}{}\section{Proxy}\label{first_code_look_first_look_Proxy}
Like the \hyperlink{class_director}{Director}, the Proxy class inherits \hyperlink{class_component_interface}{Component\-Interface}, and the application is essentially started when the \hyperlink{class_proxy_main_window}{Proxy\-Main\-Window}'s Picto\-::\-Component\-Interface\-::activate() function is called. In the Proxy's case, the function is called due to a one shot timer in the \hyperlink{class_proxy_main_window}{Proxy\-Main\-Window} constructor. Assuming that you have gone through the \hyperlink{class_director}{Director} section, you have already looked at Picto\-::\-Component\-Interface and \hyperlink{class_picto_1_1_command_channel_aafe619791fb542563544ecf50628238b}{Picto\-::\-Command\-Channel\-::process\-Responses()}. Next you should look at the \hyperlink{struct_proxy_new_session_response_handler}{Proxy\-New\-Session\-Response\-Handler}. Its Proxy\-New\-Session\-Response\-Hander\-::process\-Response() function is actually responsible for capturing and sending Proxy data to the server. Next, look at \hyperlink{class_neural_data_acq_interface}{Neural\-Data\-Acq\-Interface}. This class is implemented in each of the Proxy plugins, for Plexon, T\-D\-T and the Virtual Device. In each case, the class that implements \hyperlink{class_neural_data_acq_interface}{Neural\-Data\-Acq\-Interface} takes care of interfacing with the actual Neural Data Acquisition device. Now you should have a pretty broad sense of how the Proxy works, and you can look back at \hyperlink{class_proxy_main_window}{Proxy\-Main\-Window} for some of the G\-U\-I details.\hypertarget{first_code_look_first_look_Embedded}{}\section{Embedded Front Panel}\label{first_code_look_first_look_Embedded}
The Embedded\-Front\-Panel application is fairly simple. The main method of embedded\textbackslash{}frontpanel\textbackslash{}main.\-cpp creates a \hyperlink{class_menu}{Menu} object and a \hyperlink{class_phidgets}{Phidgets} object. \hyperlink{class_phidgets}{Phidgets} handles the interface to the Pictobox front panel and knob hardware, \hyperlink{class_menu}{Menu} handles the logic controlling what is displayed on the hardware. Start by looking at \hyperlink{class_menu}{Menu}. In particular, look at Menu\-::load\-Menus() where the various \hyperlink{class_display_mode}{Display\-Mode} options are setup, and \hyperlink{class_menu_a3a8a0e8b13f44978f239e280d78b38bd}{Menu\-::user\-Input\-Slot()} where input from the \hyperlink{class_phidgets}{Phidgets} dial cause the current \hyperlink{class_display_mode}{Display\-Mode} to switch. Next look at the \hyperlink{class_display_mode}{Display\-Mode} class and go over some of its child classes. Check out \hyperlink{class_director_interface}{Director\-Interface} to see how the Embedded\-Front\-Panel actually interfaces with the \hyperlink{class_director}{Director}. Don't spend too much time worrying about the details of the \hyperlink{class_phidgets}{Phidgets} class. It looks complicated, but is really just a translator from the world of \hyperlink{class_phidgets}{Phidgets} to the world of the Embedded\-Front\-Panel. Unless \hyperlink{class_phidgets}{Phidgets} adds some new feature or something, you probably won't need to do much to it. 