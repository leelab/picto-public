The following is a list of features that we would like to add to the \hyperlink{namespace_picto}{Picto} application suite. Some of these features are purely for the purpose of expanding \hyperlink{namespace_picto}{Picto} capability. Others are really refactorizations for the purpose of removing limitations in the the current system. Obviously this is not an exhaustive list, and the more features that we add, the more feature ideas we will undoubtedly come up with. In cases where we have given some thought to how a feature should be implemented, we have included it in this list. In other cases, implementation is entirely up to you the developer.

{\bfseries \hyperlink{namespace_picto}{Picto} Experiments should be run as part of the Qt event loop}\par
 \hyperlink{namespace_picto}{Picto} Tasks are not currently run as part of the Qt Event loop. Currently, \hyperlink{class_picto_1_1_experiment_a6cfd77559307223a8121a6a016b489c2}{Picto\-::\-Experiment\-::run\-Task()} starts a task and doesn't return until the Task is complete. In order for Tasks to run as part of the Qt event loop, we would need to set a timer to trigger a top level run\-Frame\-Logic() function every frame from the event loop. This function would locate the current Task control state, then cause all scripts to run and all transitions to be traversed until control reached the code that renders the next frame. We would then wait for first phosphor presentation in that frame, run any code that needs to happen at the time of the first phosphor, and return to the event loop. Any O\-S events, network events, etc could then happen as a natural part of the Qt event loop in the time between first phosphor presentations and processing for the next render. This would allow a whole lot of things in \hyperlink{namespace_picto}{Picto} to run a whole lot more smoothly. In particular, right now in \hyperlink{namespace_picto}{Picto} any time we send a message over the network to the \hyperlink{class_server}{Server}, rather than using the standard method of connecting to network events, we need to find a place in local logic to poll the network socket and wait for a response. Inevitably, this ends up wasting a lot of time and seriously complicating the code. The reason that \hyperlink{namespace_picto}{Picto} wasn't built to run as part of the Qt event loop in the first place is due to computers having being historically slower that they are now and the fear that allowing the \hyperlink{class_director}{Director} application to handle O\-S events might cause skipped frames. At this point it is our belief, considering the simplicity of our Experiments and the speed of new processors, that allowing the \hyperlink{class_director}{Director} application to handle O\-S events will not have any effect on frame rate. For more details on this issue, see \hyperlink{class_picto_1_1_command_channel_aafe619791fb542563544ecf50628238b}{Picto\-::\-Command\-Channel\-::process\-Responses()}. Also, note that the implementation of this feature is a very significant task that involves touching a lot of pieces of \hyperlink{namespace_picto}{Picto} code. It should definitely not be taken on as one of a new developer's first tasks.

{\bfseries Add L\-F\-P and Spike data to a \hyperlink{class_replay_viewer}{Replay\-Viewer} audio channel}\par
 Currently, while L\-F\-P and Spike data are available from Analysis code, they are not presented in any way in the \hyperlink{class_replay_viewer}{Replay\-Viewer} G\-U\-I. There are a number of possibilities for presenting this data. In the case of the \hyperlink{class_remote_viewer}{Remote\-Viewer}, the data is presented in a separate tab on a plot; however, experience shows that one of the most convenient ways to present the data is over an audio channel so that researchers can hear changes to neural data while simultaneously watching what is going on in the behavioral task. In the \hyperlink{class_remote_viewer}{Remote\-Viewer}, for various reasons, there is at least a half second delay between the current behavioral time and L\-F\-P data coming in from the neural system which makes a live audio signal less feasible. In the \hyperlink{class_replay_viewer}{Replay\-Viewer}, however, we should be able to playback neural data in an audio channel while the behavioral task is being played back. The idea would be to allow the operator to select a channel/unit and playback all spikes on that channel/unit as simple ticks. L\-F\-P data for that channel would be directly pumped into the audio stream as a background hum behind the spike ticks. In terms of implementation, the spike/lfp playback system is already in place but there is some plumbing that will need to be done in bringing the \hyperlink{class_picto_1_1_session_state_a5ab201c9c6bbe8e09774987465bcc2df}{Picto\-::\-Session\-State\-::lfp\-Changed()} and \hyperlink{class_picto_1_1_session_state_a41d2edbdbc1239351e37402c8c5d41d0}{Picto\-::\-Session\-State\-::spike\-Event()} signals up to the State\-Updater interface. Once there, we should be able to connect to those signals and send their data out to an audio channel. More recent versions of Qt have exposed a lot of new functionality for dealing with audio and multimedia in general. In searching for a method of outputing raw audio data, that would be a good place to start.

{\bfseries Add Analysis\-Visual\-Elements to the Analysis system}\par
 Currently, there is one means of output for Analyses which is the Analysis\-File\-Output. The Analysis\-File\-Output comes with a Analysis\-File\-Output\-Widget that displays output file data in a side bar of the \hyperlink{class_replay_viewer}{Replay\-Viewer} and \hyperlink{class_test_viewer}{Test\-Viewer} during playback. When we record Session playback into a video file though, we only record what happes in the main window of the \hyperlink{class_replay_viewer}{Replay\-Viewer} and it would be nice to be able to add new information to that display such that it overlays what was happening during the Session. The simplest way to do this would be to add Analysis\-Visual\-Elements that would be added to Analyses and displayed with exactly the same rules as their Experimental Visual\-Element counter parts when their Analysis was activated. There could be any number of Analysis\-Visual\-Element classes for displaying text, xy\-Plots, raster\-Plots, progress\-Bars, etc. This way, if a researcher wanted to show how a specific piece of data changes during the course of a trial, they could simply add an appropriate Analysis\-Visual\-Element and update it accordingly while the trial progressed. Imagine, for example, if we implemented a raster Analysis\-Visual\-Element. During the course of each trail, in each frame script we could use an Analysis\-Function to send the latest spikes to the raster plot. The raster could be placed at the bottom of the display such that our video file would show not only what the test subject was doing during the trial, but also how a correlated neuron's spike density changed during that trial.

{\bfseries Add Audio to video files}\par
 Currently, video files recorded from the \hyperlink{class_replay_viewer}{Replay\-Viewer} do not record sound. It turns out that adding audio to the video file is harder than you might expect. In fact, as of this writing, even with all of its new multimedia functionality Qt does not provide any convenient way of programmatically generating a video file (it's support is limited to capturing and saving images from a webcam -\/ see my stack overflow question on the topic\-: \href{http://stackoverflow.com/questions/14566470/create-video-programmatically-with-qt-5-0}{\tt http\-://stackoverflow.\-com/questions/14566470/create-\/video-\/programmatically-\/with-\/qt-\/5-\/0}). We used qtffmpegwrapper for this purpose. qtffmpegwrapper is a qt interface to the ffmpeg system and does the job in a not-\/to-\/complicated way, but does not support audio. The qtffmpegwrapper along with all necessary ffmpeg binaries is stored in \hyperlink{namespace_picto}{Picto}\textbackslash{}3rdparty\textbackslash{}qtffmpegwrapper. It will undoubtedly need to be updated at some point when Windows changes their A\-P\-I or something and can be found online at \href{https://code.google.com/p/qtffmpegwrapper/}{\tt https\-://code.\-google.\-com/p/qtffmpegwrapper/}. To add audio support to saved \hyperlink{namespace_picto}{Picto} videos though, you'll need to either change the qtffmpegwrapper code to add an audio interface (unless someone else has already done it by the time you read this), use Qt directly if it has added video writing support by now, or find some better method.

{\bfseries Integrate \hyperlink{namespace_picto}{Picto} analysis with Matlab}\par
 This feature is more of a long term goal and we haven't done much research on it as of yet. The idea is to make use of the Matlab A\-P\-I to send Analysis output data directly to Matlab. Depending on how flexible the Matlab A\-P\-I is, we could possibly put Matlab plots and other windows directly into the Analysis\-Output\-Widget\-Container, use them a pop-\/ups or simply pipe data into a running Matlab application. The method for doing this is up to you, but the idea would be to implement the interface inside a Matlab\-Analysis\-Output object (ie. Matlab\-Plot\-Analysis\-Output) that could be added to a \hyperlink{namespace_picto}{Picto} Analysis design just like any other Analysis\-Output object.

{\bfseries Put all \hyperlink{namespace_picto}{Picto} systems onto one \hyperlink{class_server}{Server}}\par
 The orignal plan for \hyperlink{namespace_picto}{Picto} was to have one central server that handles all running \hyperlink{namespace_picto}{Picto} Sessions simultaneously. In fact, the current \hyperlink{namespace_picto}{Picto} \hyperlink{class_server}{Server} is capable of handling a small number of simultaneous Sessions on different Directors so long as the Sessions are simple without large quantities of data like L\-F\-P. The problem with handling multiple Sessions at once is that there is so much overhead in writing data to S\-Q\-L. We found that due to this overhead, a single \hyperlink{namespace_picto}{Picto} Session with neural data can take up a very significant percentage of \hyperlink{class_server}{Server} processing time, and for this reason the decision was made to add system numbers so that multiple Servers could run on the same network and run a separate \hyperlink{class_server}{Server} for every Director/\-Proxy system. The fact is though, that the data saved on the \hyperlink{namespace_picto}{Picto} \hyperlink{class_server}{Server} is almost entirely serial, and there really is no need to perform any S\-Q\-L read queries on the Session data during the course of a Session. For this reason, it would make sense to reimplement the \hyperlink{class_session_info}{Session\-Info} code (and \hyperlink{class_stored_session_data}{Stored\-Session\-Data}) such that it saves data in a simple file as a simple byte array. It is certainly good for finalized Session files to be saved in S\-Q\-L for the purpose of easy upgrading and debugging, so a separate tool could be created to convert the simple serial file to an S\-Q\-L file. This tool could be run when the \hyperlink{class_server}{Server} wasn't busy handling Sessions overnight to convert the previous days saved data to S\-Q\-L Session files. In the spacial case where a Workstation wants to analyze Session data right away, we could add the tool to the Workstation so that it could perform the conversion on its own. We have not run tests of saving serial file data, but it should remove file access as the \hyperlink{class_server}{Server} bottleneck since generally file access is considered much quicker than interfacing over a network.

{\bfseries Add line numbers to \hyperlink{namespace_picto}{Picto} Scripts}\par
 We will need to extend the \hyperlink{class_script_text_edit}{Script\-Text\-Edit} class to do this.

{\bfseries Implement standardized region/manifold/channel data storage}\par
 When recording with neural data, it is important to save information about the neural recording setup used with a particular session. Currently, researchers can do this by adding the relevant data to the Run\-Notes in the \hyperlink{class_remote_viewer}{Remote\-Viewer}; however since this needs to be done by everyone for every Session, it would be good to set up a standard way to do this. It would also be very useful if the method allowed the data to be searchable in the future so that, for example, we could select out all sessions that dealt with a particular brain region. There are many ways to do this. One that comes to mind would be to add some type of additonal configuration to the \hyperlink{namespace_picto}{Picto} \hyperlink{class_server}{Server}. The \hyperlink{class_server}{Server} could be configured with a list of categories for which data could be saved and a list of possible values for each category. The Workstation could then query the saveable categories and category values when it joins/starts a Session. In the \hyperlink{class_task_run_viewer}{Task\-Run\-Viewer}, it could provide a section with a little '+' button to add a new category and category value, each of which could be filled in using drop down menus. The values entered there could then be sent to the \hyperlink{class_server}{Server} along with the Run\-Notes and saved in a searchable S\-Q\-L table in the Session file. By doing things in this way, we would make it easy to search over multiple Sessions for particular Region/\-Manifold/\-Channel values. We would also leave things general so that the categories could be set up differently for other research applications.

{\bfseries Implement get\-Token(index) function on Token\-Factory\-Graphic}\par
 We have recieved some user feedback indicating that it would be very useful to be able to treat individual tokens in a Token\-Factory\-Graphic as their own separate objects with their own functions and script properties. This would not add any new functionality to \hyperlink{namespace_picto}{Picto} but it would make design more convenient for systems that require configurable numbers of tokens. This should be doable by creating a Token class that inherits Q\-Object and interfaces with the Token\-Factory\-Graphic whenever get\-Token(index) is called and adding it to the current Q\-Script\-Engine (hopefully the current Q\-Script\-Engine is accessible somehow). Remember that whenever we add a new function or script property to anything we need to be very sure of it. As soon as someone uses a that script function/property, we need \hyperlink{namespace_picto}{Picto} to be backward compatible with it forever!

{\bfseries Allow Neural Data Acquisition systems and the Proxy to stop and start during the course of a Session}\par
 Currently, if the Plexon or T\-D\-T systems stop recording during the course of a Session, even if they restart the Proxy is unable to gather any further data until a new Session is started with that Proxy. Similarly, if a Proxy is closed accidentally, even if it is opened again it cannot reconnect to its Session and continue gathering data. It would be good if we could support these functions.

{\bfseries Add settable waveform sample period to Proxy}\par
 Currently, every waveform that is recorded on the T\-D\-T or Plexon systems is sent to the \hyperlink{class_server}{Server} and saved to the Session file. This wastes space since it really is not necessary to save every single waveform. It would be nice to add an option to the Proxy window to select the waveform sample period.

{\bfseries Add \char`\"{}link to syntax error\char`\"{} in \hyperlink{class_state_edit_viewer}{State\-Edit\-Viewer}}\par
 The \hyperlink{class_state_edit_viewer}{State\-Edit\-Viewer} includes a syntax checker system that reports script and structural errors in a tab of the bottom centeral widget. It would be nice if you could click on these errors and cause the \hyperlink{class_state_edit_viewer}{State\-Edit\-Viewer} context to automatically move to the element with the error. In the case of script syntax errors, it would be nice if the cursor could automatically enter the problematic script at the error line.

{\bfseries Allow a \hyperlink{class_director}{Director} to determine if it supports a given Experiment}\par
 Some Experiment designs include elements that may not be supported by a \hyperlink{class_director}{Director}. For example, a \hyperlink{class_director}{Director} running on a Pictobox that is connected to a Neural Data Aquisition system is configured without the \char`\"{}-\/onesided\char`\"{} tag since it uses its parallel port to send alignment codes to the neural system. This means that that \hyperlink{class_director}{Director}'s parallel port can't be used as an output for a Binary\-Data\-Output object. If an Experiment loaded onto that \hyperlink{class_director}{Director} included a Binary\-Data\-Output object, it would be useful if the \hyperlink{class_director}{Director} could send a N\-O\-T\-S\-U\-P\-P\-O\-R\-T\-E\-D command to let the Workstation know that the \hyperlink{class_director}{Director} cannot run that Experiment and either the \hyperlink{class_director}{Director} needs to be reconfigured or the Design adjusted.

{\bfseries Speed up Undo/\-Redo and Delete operations}\par
 For code simplicity's sake, the Undo/\-Redo and Delete operations all involve reloading a serialized Design from scratch. In the case of a Delete, we do this to make sure that everything is set up in a clean way after the delete is completed. In the case of Undo and Redo, we do this in order to make use of the Q\-Text\-Document's built in Undo / Redo functionality. All we have to do is change an underlying Q\-Text\-Document containing the Design's serialized X\-M\-L whenever an important operation happens. To Undo or Redo, we just call Undo or Redo on that Q\-Text\-Document then reload the Design from X\-M\-L. The problem with this approach is that it is very slow. There are two ways to solve this. The first would be to speed up the deserialization process. We might accomplish this by streamligning the Asset\-Factory system, wherein multiple different Asset\-Factory objects are created for every object in the State\-Machine tree. Also, part of the complexity in the serialization system is due to the fact that \hyperlink{namespace_picto}{Picto} orignally included a \hyperlink{class_text_viewer}{Text\-Viewer} that showed the actual X\-M\-L code underlying the Experiment and allowed the user to change it. We wanted to make sure that every operation in the \hyperlink{class_state_edit_viewer}{State\-Edit\-Viewer} could be undone in a way that would affect only the exact area of code where the change occured but leave everything else intact. In particular, we were concerned that the tabbing and xml comments shouldn't get changed or moved due to actions in the \hyperlink{class_state_edit_viewer}{State\-Edit\-Viewer}. Now that the \hyperlink{class_text_viewer}{Text\-Viewer} is no longer used these concerns are less important and if need be the serialization code could be made more efficient at the expense of allowing \hyperlink{class_state_edit_viewer}{State\-Edit\-Viewer} operations to change more significant portions of the X\-M\-L design file. Still, it is likely that this won't be sufficient to really get the kind of speed that we want. The other option would be to implement the Undo/\-Redo/\-Delete in a completely different way, and this would be a big job. For Delete, it would mean very carefully going through the State\-Machine tree code and making sure that a Delete won't break anything (currently actually deleting an element only sets a flag saying \char`\"{}don't serialize this element\char`\"{} out, this would mean actually deleting the element when delete is called). For Undo and Redo, we would need to carefully define a command dispatch system that defines \char`\"{}do\char`\"{} and \char`\"{}undo\char`\"{} effects for every possible type of user action. Then representations of the user actions would be added to a stack after being performed and we could move backwords through that stack performing \char`\"{}undo\char`\"{} effects when we Undo and forward performing \char`\"{}do\char`\"{} effects when we Redo.

{\bfseries Create a State\-Machine\-Tree\-View}\par
 Currently, we can only look at one level of the State\-Machine tree at a time. It would be useful to add an additional widget in the style of the Windows directory tree that would let us look at multiple levels of the tree at the same time.

{\bfseries Unauthorized Workstation's need a way to see if the Session is running}\par
 When unauthorized Workstations join a Session, their play/pause/stop buttons are greyed out since they are not allowed to control the Session. This means that they can't see the colors of those buttons, and that means that they can't differentiate between things like a Session that is stopped and one that is paused with no visible Visual\-Elements.

{\bfseries Rebuild Neural Channel/\-Unit lists in the \hyperlink{class_remote_viewer}{Remote\-Viewer} whenever a Run is started}\par
 The \hyperlink{class_remote_viewer}{Remote\-Viewer}'s \hyperlink{class_neural_viewer}{Neural\-Viewer} keeps track of which channels/units have data on them and adds those channels/units to its lists the first time that data is received. These lists are not cleared until the Workstation detaches from the Session though, so a channel that was active in one run but not used in another can stick around in the \hyperlink{class_remote_viewer}{Remote\-Viewer} U\-I even though it is completely empty. This should be fixed so that the channel/unit lists are cleared and rebuilt each time a new Run starts.

{\bfseries Add verification that no two in-\/scope Output\-Signal elements are controlling the same output port at the same time}\par
 There is currently no syntax verification for checkihg whether two Output\-Signal elements that are in scope at the same time are trying to control the same digital output port. This is a design error and verification code to this effect should be added to the Design tree.

{\bfseries Create a \hyperlink{namespace_picto}{Picto} Installer}\par
 \hyperlink{namespace_picto}{Picto} is currently installed by copying over a standard group of binaries and running a \char`\"{}\-Visual Studio Redistributable\char`\"{} installation. We should create a simple one shot installer for \hyperlink{namespace_picto}{Picto} at some point to streamline this process.

{\bfseries Refactor the \hyperlink{class_test_viewer}{Test\-Viewer} as a master and slave Experiment running in parallel}\par
 Once we have refactored the Experiment run system to be part of the Qt event loop, it should be fairly straightforward to implement the \hyperlink{class_test_viewer}{Test\-Viewer} as a master Experiment running in a Qt Window sending data to a slave Experiment that handles Analysis. This will help us prepare for implementing real time \hyperlink{namespace_picto}{Picto} Analysis.

{\bfseries Implement real-\/time Session Analysis}\par
 The idea here is to allow the \hyperlink{class_remote_viewer}{Remote\-Viewer} to analyze an Actively running Session. This will take a lot of thought. Some challenges here are that the Analysis needs all data from the beginning of the Run. It can't just look at the latest data as the current system does. Another challenge is in dealing with Analysis\-Data\-Source objects. These may ask for future data which simply has not happened yet. To handle situations like this, we may need to use two separate slave Experiments in the \hyperlink{class_remote_viewer}{Remote\-Viewer}. One would show realtime behavioral data, and another would run in the background and perform Analysis. The Analysis Slave Experiment would need some way to stop running whenever Analysis code requested \char`\"{}future\char`\"{} data that hadn't been generated yet and restart when the data bacame available. 